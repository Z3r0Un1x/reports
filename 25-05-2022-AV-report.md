# Tìm hiểu cách thức hoạt động của Antivirus



[TOC]

## I. Định nghĩa về chương trình diệt virus

Chương trình diệt virus (Antivirus hay AV) là một chương trình có nhiệm vụ tìm và ngăn chặn các loại mã độc thực thi trên thiết bị của người dùng cuối. Các AV ngày nay có thể bảo vệ người dùng khỏi các mối nguy hiểm từ Internet như ransomware, backdoor, rootkit, spyware, adware, ... Ngoài ra, một số AV còn có khả năng đảm bảo tính riêng tư của người dùng, cảnh báo các trang web lừa đảo hay thậm chí phát hiện được các cuộc tấn công của những nhóm APT.

Một số sản phẩm, nhà cung cấp AV phổ biến hiện nay như: Avast, ESET, Kaspersky, Microsoft (Windows Defender), ...

## II. Cách thức hoạt động cơ bản của AV

Về cách thức hoạt động thì AV có những mô-đun chính sau:

- Quét và nhận diện mã độc tĩnh (signature-based detection)
- Nhận diện hành vi theo thời gian thực (Real-time protection)
- Cơ chế tự bảo vệ (Self-protection module)

Biểu diễn hướng hoạt động của AV cơ bản như sau:

![](https://raw.githubusercontent.com/Z3r0Un1x/image-host/main/img-container/2022-05-26_12-56.png)

### a. Nhận diện mã độc qua mã băm (hashing)

Bằng cách sử dụng các thuật toán băm như MD5, SHA1, SHA256 (phổ biến), SHA512; AV có thể kiểm tra một chương trình hay một đoạn mã và đối chiếu hash của chúng với database chứa những mã hash của các chương trình độc hại đã được tìm thấy trước đó.

Khi sử dụng cách nhận diện này, AV có thể nhanh chóng phát hiện các đoạn mã độc từ Internet. Tuy nhiên, cách này cũng có lỗ hổng khi malware ngày nay thường có cơ chế tự biến đổi (polymorphic).

Ví dụ như hàm `morphcode` trong ransomware Conti V3.7:

![](https://raw.githubusercontent.com/Z3r0Un1x/image-host/main/img-container/image-20220526121239254.png)

Khi ransomware được chạy hoặc biên dịch thì nó sẽ sinh ra một biến rác ngẫu nhiên dựa trên [hàm sinh tuyến tính](https://www.cplusplus.com/reference/random/linear_congruential_engine/linear_congruential_engine/) với giá trị thuộc khoảng từ 0 đến MAX_INT32 (`0x7FFFFF`), tiếp đó biến trên sẽ không bị tối ưu hoá đi (volatile) và sẽ liên tục thay chính nó dẫn đến thay đổi cả signature khiến cho việc nhận diện đoạn mã độc này khó khăn hơn với AV.

### b. Phân tích hành vi của chương trình

Đối với userland, AV có các kỹ thuật để phân tích hành vi của chương trình như Win32 API hooking, bằng cách chuyển các lời gọi hàm API qua một chuỗi các thủ tục trước khi cho phép chương trình thực thi, AV có thể biết được toàn bộ giá trị tham số, thông tin của người gọi hàm API để từ đó có biết được những đoạn mã độc ở đâu, thuộc tiến trình nào. Tuy nhiên sau một thời gian thì malware lại gọi Native  API trực tiếp từ `ntdll.dll` để bypass Win32 API hooking, thì lúc này AV lại tiếp tục hook các hàm có trong `ntdll.dll`. Các tiến trình malware đã tiếp tục sử dụng các kỹ thuật khác như API unhooking, custom lại syscall, ...

Ví dụ đối với syscall của `NtCreateFile`:

![](https://raw.githubusercontent.com/Z3r0Un1x/image-host/main/img-container/2022-05-26_13-26.png)

Malware có thể sao chép lại đoạn syscall trên và tạo một hàm cùng signature với `NtCreateFile` để gọi và bypass được hook của AV.

Cách thứ hai là API unhooking thì malware có thể map lại bản gốc của `ntdll.dll` vào trong bộ nhớ rồi ghi đè .text section của bản gốc lên `ntdll.dll` bị hook.

![Nguồn: Internet](https://raw.githubusercontent.com/Z3r0Un1x/image-host/main/img-container/image.png)

Sau đó malware chỉ cần cài lại cơ chế bảo vệ của vùng nhớ (sử dụng `VirtualProtect`) của `ntdll.dll` là đã có thể unhook toàn bộ API và sử dụng cho mục đích riêng.

Để đối phó với những vấn đề mới nêu trên, AV đã chuyển sang tầng kernel và vá lại (patching) System Service Dispatch Table (SSDT), sau đó chuyển tiếp hướng thực thi của malware về lại các mô-đun của AV. Cho dễ hiểu thì SSDT sẽ chứa toàn bộ ID của các syscall, giả sử với hàm `NtCreateFile` như ở ví dụ vừa rồi thì nó sẽ có ID là `0x55`, khi tra ID này trong SSDT sẽ trỏ đến vị trí của System Service Descriptor Table (KeServiceDescriptorTable) được export trong `Ntoskrnl.exe`.

![Nguồn: Internet](https://raw.githubusercontent.com/Z3r0Un1x/image-host/main/img-container/image (1).png)

AV sẽ chỉnh lại vị trí của `NtCreateFile` trong SSDT vào một hàm thuộc bản thân nó để bắt đầu phân tích thay vì dẫn đến đúng vùng nhớ chứa bản gốc của hàm vừa gọi. Cách làm này có nhược điểm rất lớn đó là việc chạy và tương tác với tầng kernel khiến cho hệ điều hành không được ổn định vì các tiến trình hay driver ở đây đều chia sẻ chung một bộ nhớ, nếu AV bị crash ở tầng này thì toàn bộ hệ thống sẽ bị lỗi màn hình xanh (BSOD) do PatchGuard sẽ gọi `KeBugCheck(0x109)` với mô tả lỗi là `CRITICAL_STRUCTURE_CORRUPTION`. Chính vì vậy nên Microsoft đã vô hiệu hoá phương thức này bằng cấm không cho sửa SSDT nữa và thay thế bằng **Kernel Callback**.

Ta đã biết sơ về kernel, vậy còn khái niệm callback nghĩa nôm na là khi một hàm `A` được gọi, nó sẽ đưa ra một thông báo hoặc `SetEvent` một flag toàn cục cho một hàm `B` khác đã đăng ký callback với nó. Và kernel callback cũng tương tự, driver của AV sẽ đăng ký callback cho một số hàm nhất định và sẽ nhận được thông báo cả trước lẫn sau khi các hàm nhất định đó được gọi. Một số callback được sử dụng rất nhiều, đặc biệt là [`PsSetCreateProcessNotifyRoutine()`](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-pssetcreateprocessnotifyroutine).

Giả sử khi một malware muốn nhân bản chính nó, thì nó sẽ phải gọi `NtCreateFile`, `CopyFile` và trong tham số của `CopyFile` có đường dẫn tới chính nó, cuối cùng là chạy những file vừa tạo. AV sẽ sử dụng callback để khi nào một trình tự các API được gọi là `NtCreateFile` -> `CopyFile` -> `CreateProcess` được gọi thì AV sẽ cảnh báo cho người dùng và huỷ tiến trình gọi các API trên. Một ví dụ khác khi malware muốn thực hiện kỹ thuật process injection thì AV sẽ bắt các API theo mẫu sau: `CreateRemoteThread` -> `VirtuallAlloc` -> `WriteMemory` -> `VirtualProtect`.

Vậy làm sao để malware vượt qua được kernel callback? Khi `PsSetCreateProcessNotifyRoutine()` được gọi, AV sẽ đăng ký một danh sách các hàm và trỏ về lại hàm xử lý trong driver của nó, malware sẽ lợi dụng điểm này và vá lại hàm xử lý của AV, ví dụ ta có hàm xử lý ban đầu như sau:

```assembly
AV_driver!HandleCallback:
mov [rsp+8], RCX
push r15
push r14
push r13,
sub rsp, 18h
...
```

Malware chỉ cần thêm một byte `0xC3`, hay `ret`, vào dưới prolog của hàm xử lý và vô hiệu hoàn toàn chức năng kể trên:

```assembly
AV_driver!HandleCallback:
mov [rsp+8], RCX
push r15
push r14
push r13
sub rsp, 18h
ret
...
```

### c. Cơ chế tự bảo vệ

Hầu hết AV hiện đại đều có cơ chế tự bảo vệ các mô-đun của nó không bị chỉnh sửa, can thiệp hoặc bị tắt đi bởi các phần mềm độc hại. Các tính năng thường thấy của cơ chế này bao gồm như:

- Các người dùng thông thường và thậm chí cả người dùng với quyền quản trị (administrator) cũng không thể tuỳ ý đóng các tiến trình đang chạy của AV bằng cách thông thường (end process của Task Manager, taskkill, ...)

- Các dịch vụ (service) của AV thường đã được cấu hình DACL nên cả người dùng thông thường hay có quyền quản trị đều không thể truy vấn thông tin hay chỉnh sửa thông số của các dịch vụ này

- Các tiến trình và dịch vụ của một số AV sẽ nằm dưới quyền quản lý của một tài khoản đặc biệt mà ta không thể truy cập hoặc truy vấn thông tin.

  ![](https://raw.githubusercontent.com/Z3r0Un1x/image-host/main/img-container/2022-05-26_14-58.png)

- Đa phần các AV sẽ có một mô-đun chạy kèm để quản lý và theo dõi liên tục các tiến trình thuộc AV đó, các mô-đun này thường sẽ giao tiếp với driver của AV ở tầng kernel và bảo vệ vùng nhớ của các mô-đun khác.
- Cuối cùng là sử dụng cơ chế **P**rotected **P**rocess **L**ight (PPL) của Microsoft, cũng là cách phổ biến nhất.

#### Protected Process Light

Kể từ Windows 8.1, một hô hình bảo vệ mới ở tầng kernel được thêm vào hệ điều hành và tên của mô hình này là Protected Process Light. Cách thức hoạt động của mô hình này là Windows sẽ xét tính toàn vẹn của một tiến trình và chỉ cho phép những tiến trình được tin tưởng này chạy dưới sự kiểm soát của PPL. Vậy khi được load trong PPL, các tiến trình này sẽ được Windows bảo vệ khỏi các kỹ thuật như code injection và các cách tấn công khác khi malware có quyền administrator. Việc này hoàn toàn khả thi do **chỉ có các tiến trình trong PPL mới có thể tương tác với nhau** mà các tiến trình nằm ngoài mô hình này không thể chỉnh sửa hay giả mạo được. Nhờ vào PPL, bản thân các AV không cần phải tốn tài nguyên cho các tiến trình tự bảo vệ khác.

Kể cả với quyền SYSTEM và SeDebugPrivilege, ta cũng không thể tắt được các tiến trình thuộc PPL:

```
C:\WINDOWS\system32>whoami
nt authority\system

C:\WINDOWS\system32>whoami /priv | findstr "Debug"
SeDebugPrivilege Debug programs Enabled

C:\WINDOWS\system32>taskkill /f /im MsMpEng.exe
ERROR: The process "MsMpEng.exe" with PID 2236 could not be terminated.
Reason: Access is denied.
```

Tuy nhiên, Microsoft cũng rất rõ ràng và gắt gao trong việc cấp quyền để các chương trình được bảo vệ bằng mô hình PPL để tránh việc malware lợi dụng và cài chính nó vào PPL. Để có thể chạy một ứng dụng với PPL, các nhà cung cấp dịch vụ phải trải qua một quá trình chọn lọc (vetting process) để chứng minh phần mềm của họ có thể tin tưởng được, tiếp đến các nhà phát triển AV phải cài thêm một driver đặc biệt gọi là ELAM (Early Lauch Anti-Malware) driver và có đầy đủ chữ kỹ điện tử (Code Signing) để Microsoft Authenticode xét duyệt. Sau toàn bộ các bước trên, AV có thể sử dụng ELAM driver được cấp để thêm các tiến trình của họ vào PPL.

Để có thể bypass được PPL, giả sử ta đã có quyền SYSTEM và giờ ta muốn tắt một tiến trình PPL của AV thì do mỗi tiến trình (kể cả PPL) đều được chia quyền và xác định bằng một dạng token (Token Security Descriptor) bao gồm các SID. Một chuỗi SID của một tiến trình sẽ đại diện cho quyền và sở hữu của tiến trình đó, ví dụ như một chuỗi SID của tiến trình thuộc Windows:

![](https://raw.githubusercontent.com/Z3r0Un1x/image-host/main/img-container/2022-05-26_15-55.png)

Ta có thể thấy chuỗi SID của `wininit.exe` là `S-1-5-18`, tra trong bảng RID của MSDN

![](https://raw.githubusercontent.com/Z3r0Un1x/image-host/main/img-container/2022-05-26_15-57.png)

ta thấy được `wininit.exe` có quyền SYSTEM, được quản lý bởi một tài khoản đặc biệt của hệ thống và đặc biệt, `wininit.exe` cũng là một PPL (`PsProtectedSignerWinTcb-Light`). Để có thể tắt được tiến trình này thì lúc trước ta chỉ cần thay đổi SID của `wininit.exe` thành SID của một tiến trình thông thường và `wininit.exe` sẽ mất đi sự bảo vệ tư PPL.

Windows đã có bản vá cho kiểu tấn công này bằng cách thêm một ACE cho SACL là "TrustLabel" cho các PPL. Windows sẽ tìm và lọc ra các tiến trình có TrustLabel ACE và chặn quyền TOKEN_WRITE đến các tiến trình này.

Ngoài ra, một số AV cũng sử dụng PPLGuard để thêm TrustLabel ACE vào các tiến trình của bản thân để cải thiện cơ chế tự bảo vệ.

## III. Cách AV cách ly malware

Sau khi đã nhận diện được malware, các AV thường cho chúng ta các lựa chọn như: Xoá, Cách ly, Bỏ qua, ... một số AV mới còn có công nghệ khử mã độc nâng cao nhằm xoá đi chỉ phần đoạn mã gây hại và để lại chương trình sạch cho người dùng, thường là các file phim ảnh, crack game hoặc các phần mềm lậu khác. Ở phần này ta sẽ nói sâu về việc AV cách ly malware như thế nào.

Việc AV cho phép ta cách ly những file được xem là malware là để phòng trường hợp nhầm lẫn (false positive) và người dùng có thể chọn phục hồi lại file bị cách ly đó hay không. Khi cách ly, phần mềm AV phải chắc chắn rằng người dùng không vô tình bấm lại và thực thi file mã độc đó nên thường chúng sẽ có một cơ chế mã hoá file hẳn hoi chứ không chỉ đơn giản là đổi phần mở rộng.

EICAR test file trước và sau khi được cách ly:

![](https://raw.githubusercontent.com/Z3r0Un1x/image-host/main/img-container/2022-05-26_16-30.png)

![](https://raw.githubusercontent.com/Z3r0Un1x/image-host/main/img-container/2022-05-26_16-30_1.png)

Thay đổi tên và biến đổi lại một chút:

![](https://raw.githubusercontent.com/Z3r0Un1x/image-host/main/img-container/2022-05-26_16-35.png)

Ta thấy được tên file được đổi thành một dạng hash SHA1 và cả 2 file cách ly đều có phần mở đầu tương tự nhau (`0B AD 00 98 91 FD DE`), phần này có thể xem như signature của file cách ly. Để có thể khôi phục lại những file này, Windows Defender sẽ có một cơ chế decrypt riêng, đối với những loại AV khác như Kaspersky, Sophos, Malwarebytes thì các thuật toán cơ bản như XOR, RC4, ... cũng được sử dụng để mã hoá file cách ly.