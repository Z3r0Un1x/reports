# Tìm hiểu cách thức hoạt động của Antivirus



[TOC]

## I. Định nghĩa về chương trình diệt virus

Chương trình diệt virus (Antivirus hay AV) là một chương trình có nhiệm vụ tìm và ngăn chặn các loại mã độc thực thi trên thiết bị của người dùng cuối. Các AV ngày nay có thể bảo vệ người dùng khỏi các mối nguy hiểm từ Internet như ransomware, backdoor, rootkit, spyware, adware, ... Ngoài ra, một số AV còn có khả năng đảm bảo tính riêng tư của người dùng, cảnh báo các trang web lừa đảo hay thậm chí phát hiện được các cuộc tấn công của những nhóm APT.

Một số sản phẩm, nhà cung cấp AV phổ biến hiện nay như: Avast, ESET, Kaspersky, Microsoft (Windows Defender), ...

## II. Cách thức hoạt động cơ bản của AV

Về cách thức hoạt động thì AV có những mô-đun chính sau:

- Quét và nhận diện mã độc tĩnh (static detection)
- Nhận diện hành vi theo thời gian thực (Real-time protection)
- Cơ chế tự bảo vệ (Self-protection module)

Biểu diễn hướng hoạt động của AV cơ bản như sau:

![](https://raw.githubusercontent.com/Z3r0Un1x/reports/main/img-container/2022-05-26_12-56.png)

### a. Nhận diện mã độc tĩnh

#### Mã băm (File hashing)

Đây là phương pháp lâu đời và truyền thống nhất, bằng cách sử dụng các thuật toán băm như MD5, SHA1, SHA256 (phổ biến), SHA512; AV có thể kiểm tra một chương trình hay một đoạn mã và đối chiếu hash của chúng với database chứa những mã hash của các chương trình độc hại đã được tìm thấy trước đó.

Khi sử dụng cách nhận diện này, AV có thể nhanh chóng phát hiện các đoạn mã độc từ Internet. Tuy nhiên, cách này cũng có lỗ hổng khi malware ngày nay thường có cơ chế tự biến đổi (polymorphic).

Ví dụ như hàm `morphcode` trong ransomware Conti V3.7:

![](https://raw.githubusercontent.com/Z3r0Un1x/reports/main/img-container/2022-05-26_12-12.png)

Khi ransomware được chạy hoặc biên dịch thì nó sẽ sinh ra một biến rác ngẫu nhiên dựa trên [hàm sinh tuyến tính](https://www.cplusplus.com/reference/random/linear_congruential_engine/linear_congruential_engine/) với giá trị thuộc khoảng từ 0 đến MAX_INT32 (`0x7FFFFF`), tiếp đó biến trên sẽ không bị tối ưu hoá đi (volatile) và sẽ liên tục thay chính nó dẫn đến thay đổi cả signature khiến cho việc nhận diện đoạn mã độc này khó khăn hơn với AV.

#### Quét chuỗi 

AV có thể nhận diện ban đầu (fingerprinting) malware bằng cách kiểm tra tên file, tên cửa sổ (window title), vị trí của file xem có khả nghi hay không trước. Đối với các loại malware, mã độc phổ biến thì khi được cài đặt sẽ có những tên file đặc trưng, dựa vào đây AV có thể xác định và lưu ý những đối tượng này.

```
Image name contains "Loadlibr"
Image name contains "Rng "
Image name contains "\A0\E7\FF\FF\FF\81"
Image name contains "RNG "
Image name contains "\90\E5\43\55"
Image name contains "2.6.ex"
Image name contains "TempFile.exe"
Image name contains "mimikat"
```

Tương tự với tên cửa sổ, AV sẽ mở và duyệt qua từng cửa sổ hiện hành để kiểm tra tên của chúng có nằm trong blacklist hay không:

```c
        // DOES WINDOW TITLE MATCH ANY OF THE BLACKLISTED TITLES?
        if (!contains(window_title_report.window_title, "CheatAut") &&
            !contains(window_title_report.window_title, "pubg_kh") &&
            !contains(window_title_report.window_title, "conl -") &&
            !contains(window_title_report.window_title, "PerfectA") &&
            !contains(window_title_report.window_title, "AIMWA") &&
            !contains(window_title_report.window_title, "PUBG AIM") &&
            !contains(window_title_report.window_title, "HyperChe"))
            continue;
```

Kiểm tra vị trí của các file thực thi tại một số điểm đáng ngờ:

```
\Desktop\
\Temp\
\FileRec
\Documents\
\Downloads\
\Roaming\
```

Một số AV sẽ nhận diện malware theo các chuỗi có trong bộ nhớ của chúng, ta cũng sẽ lấy ví dụ ransomware Conti thì nó sẽ có một đoạn chuỗi được hardcode trực tiếp vào trong chương trình để tạo một singleton mutex:

![](https://raw.githubusercontent.com/Z3r0Un1x/reports/main/img-container/2022-05-27_14-27.png)

Bằng cách phân tích hàm mã hoá OBFA, ta có thể có được bản gốc của mutex này và AV sẽ lưu chuỗi trên vào trong database để mỗi khi mutex được khởi tạo hoặc bất cứ chương trình nào có chứa chuỗi tương ứng trong bộ nhớ thì AV cũng có thể nhận diện và ngăn chặn sớm hơn.

Ngoài ra còn có một cách khác mà AV sử dụng thay vì tìm trực tiếp từng chuỗi vì các mutex này có thể bị thay đổi dễ dàng, đó là sử dụng string pattern (chuỗi có quy tắc). Sau đây là ví dụ của một chương trình DRM tìm các chuỗi có trong các phần mềm gian lận (HackTool) bằng string pattern:

```
[05 18] ojects\PUBGChinese
[05 17] BattleGroundsPrivate_CheatESP
[05 17] [%.0fm] %s
[05 3E] \00\00\00\00Neck\00\00\00\00Chest\00\00\00\00\00\00\00Mouse 1\00
[05 3F] PlayerESPColor
[05 40] Aimbot: %d\00\2D\3E\20\41
[05 36] HackMachine
[05 4A] VisualHacks.net
[05 50] \3E\23\2F\65\3E\31\31\4E\4E\56\3D\42\76\28\2A\3A\2E\46\3F\75\75\23\28\67\52\55\2E\6F\30\58\47\48
[05 4F] DLLInjection-master\\x64\\Release\\
[05 52] NameESP
[05 48] Skullhack
[05 55] .rdata$zzzdbg
[05 39] AimBot
[05 39] \EB\49\41\80\3C\12\3F\75\05\C6\02\3F\EB\38\8D\41\D0\0F\BE\C9\3C\09\77\05\83\E9\30\EB\06\83\E1\DF
[05 5F] \55\E9
[05 5F] \57\E9
[05 5F] \60\E9
[05 68] D3D11Present initialised
[05 6E] [ %.0fM ]
[05 74] [hp:%d]%dm
[05 36] \48\83\64\24\38\00\48\8D\4C\24\58\48\8B\54\24\50\4C\8B\C8\48\89\4C\24\30\4C\8B\C7\48\8D\4C\24\60
[05 36] \74\1F\BA\80\00\00\00\FF\15\60\7E\00\00\85\C0\75\10\F2\0F\10\87\80\01\00\00\8B\87\88\01\00\00\EB
[05 36] \40\F2\AA\15\6F\08\D2\89\4E\9A\B4\48\95\35\D3\4F\9CPOSITION\00\00\00\00COL
[05 7A] \FF\E0\90
[05 79] %s\00\00%d\00\00POSITION\00\00\00\00COLOR\00\00\00\00\00\00\00
[05 36] \8E\85\76\5D\CD\DA\45\2E\75\BA\12\B4\C7\B9\48\72\11\6D\B9\48\A1\DA\A6\B9\48\A7\67\6B\B9\48\90\2C
[05 8A] \n<assembly xmlsn='urn:schemas-mi
```

Hiện nay các chương trình AV cũng cài đặt các tính năng tìm kiếm theo chuỗi trong cơ chế hoạt động của mình, đặc biệt là sự góp mặt của YARA. Các quy tắc YARA rất dễ đọc hiểu và ứng dụng nên các chuyên gia thường sử dụng YARA để nhận diện đa phần các loại mã độc và những biến thể của chúng một cách nhanh chóng trong khi phương pháp hashing truyền thống chỉ nhận diện được từng loại mã độc một. Bằng cách chỉ cần tìm ra một quy luật, cấu trúc hay một offset có dữ liệu không đổi nhất định, YARA có thể biết được các biến thể mà không cần phải tiến hành băm từng file.

Giả sử ta có một file EICAR như sau:

![](https://raw.githubusercontent.com/Z3r0Un1x/reports/main/img-container/2022-05-27_14-48.png)

Khi phân tích, AV không cần phải đọc từng byte một hoặc hash toàn bộ file mà nó chỉ cần lựa ra chuỗi byte `45 49 43 41 52` và xác định được đây là loại file nào thuộc chủng malware nào. Và khi mã độc thêm hay chỉnh sửa lại đoạn byte trên, AV vẫn có thể sử dụng wildcard trong YARA để xử lý. Ví dụ khi đoạn byte trên có thể được đổi thành `45 00 00 41 52` hay `45 10 00 41 52` thì với đoạn string pattern là `{45 ?? ?? 41 52}` thì AV có thể nhận diện được. Kể cả nếu malware có thêm một lượng byte nhất định như `45 00 00 01 02 03 49 43 41 52`, với quy tắc YARA `{45 [1-10] 49 43 41 52}` thì ta vẫn có thể nhận dạng được đoạn mã độc trên.

#### Import hashing

Mỗi file thực thi (PE) sẽ có một **I**mport **A**ddress **T**able (IAT) để chương trình có thể tìm và gọi các hàm từ những thư viện khác nhau. AV có thể hash IAT và biết được các mã độc có phải là biến thể từ một nguồn đã được xác định hay không. Thì thuật toán của Import hasing như sau:

- Mở IAT của PE và map lại toàn bộ số thứ tự của từng hàm (do có một số thư viện như oleaut32, ws2_32, wsock32 chỉ có số thứ tự chứ không có tên hàm cụ thể), tên hàm và cả các DLL chứa những hàm này
- Chuyển thông tin vừa map ở trên thành dạng viết thường (lowercase)
- Sắp xếp lại các hàm theo thứ tự và sinh ra một đoạn hash MD5 dựa trên thông tin vừa tổng hợp

Vậy là sau khi hash IAT thì AV có thể đối chiếu với các hash IAT của malware khác trong database.

**Lưu ý:** Đối với những mã độc viết bằng .NET thì import hashing sẽ không sử dụng được nên ta sẽ chuyển qua hash các namespace, kiểu dữ liệu. Cách này được gọi là TypeRefHash.

#### TypeRefHash (TRH)

Cũng tương tự như import hashing, TRH sẽ hash các namespace và kiểu dữ liệu của một chương trình .NET. Lý do tại sao import hashing lại không hoạt động được là vì các chương trình .NET chỉ sử dụng gần như là chỉ một mình `mscoree.dll`.

Trong khi các PE thông thường gọi API từ các DLL bằng IAT, .NET lưu những namespace và kiểu dữ liệu tham chiếu (referenced type) của nó ở một bảng, tạm gọi là Metadata table và cách bố trí dữ liệu trong bảng này cũng khá giống IAT.

![](https://raw.githubusercontent.com/Z3r0Un1x/reports/main/img-container/2022-05-27_14-49.png)

Để tính được hash của một bảng TypeRef:

- Sắp xếp lại toàn bộ bảng theo TypeNamespace trước và sau đó là sắp xếp theo TypeName
- Nối TypeNamespace và TypeName lại bằng dấu `-`, đối với những TypeName không có namespace thì chuỗi sẽ bắt đầu bằng ký tự `-`. Ví dụ `DebuggingModes` không thuộc namespace nào nên chuỗi nối của nó sẽ là `-DebuggingModes`
- Nối tất cả các chuỗi trên bằng dấu `,` và tính hash của chuỗi này (MD5/SHA1/SHA256)

### b. Phân tích hành vi của chương trình

#### API hooking và Kernel callback

Đối với userland, AV có các kỹ thuật để phân tích hành vi của chương trình như Win32 API hooking, bằng cách chuyển các lời gọi hàm API qua một chuỗi các thủ tục trước khi cho phép chương trình thực thi, AV có thể biết được toàn bộ giá trị tham số, thông tin của người gọi hàm API để từ đó có biết được những đoạn mã độc ở đâu, thuộc tiến trình nào. Tuy nhiên sau một thời gian thì malware lại gọi Native  API trực tiếp từ `ntdll.dll` để bypass Win32 API hooking, thì lúc này AV lại tiếp tục hook các hàm có trong `ntdll.dll`. Các tiến trình malware đã tiếp tục sử dụng các kỹ thuật khác như API unhooking, custom lại syscall, ...

Ví dụ đối với syscall của `NtCreateFile`:

![](https://raw.githubusercontent.com/Z3r0Un1x/reports/main/img-container/2022-05-26_13-26.png)

Malware có thể sao chép lại đoạn syscall trên và tạo một hàm cùng signature với `NtCreateFile` để gọi và bypass được hook của AV.

Cách thứ hai là API unhooking thì malware có thể map lại bản gốc của `ntdll.dll` vào trong bộ nhớ rồi ghi đè .text section của bản gốc lên `ntdll.dll` bị hook.

![Nguồn: Internet](https://raw.githubusercontent.com/Z3r0Un1x/reports/main/img-container/image.png)

Sau đó malware chỉ cần cài lại cơ chế bảo vệ của vùng nhớ (sử dụng `VirtualProtect`) của `ntdll.dll` là đã có thể unhook toàn bộ API và sử dụng cho mục đích riêng.

Để đối phó với những vấn đề mới nêu trên, AV đã chuyển sang tầng kernel và vá lại (patching) System Service Dispatch Table (SSDT), sau đó chuyển tiếp hướng thực thi của malware về lại các mô-đun của AV. Cho dễ hiểu thì SSDT sẽ chứa toàn bộ ID của các syscall, giả sử với hàm `NtCreateFile` như ở ví dụ vừa rồi thì nó sẽ có ID là `0x55`, khi tra ID này trong SSDT sẽ trỏ đến vị trí của System Service Descriptor Table (KeServiceDescriptorTable) được export trong `Ntoskrnl.exe`.

![Nguồn: Internet](https://raw.githubusercontent.com/Z3r0Un1x/reports/main/img-container/image (1).png)

AV sẽ chỉnh lại vị trí của `NtCreateFile` trong SSDT vào một hàm thuộc bản thân nó để bắt đầu phân tích thay vì dẫn đến đúng vùng nhớ chứa bản gốc của hàm vừa gọi. Cách làm này có nhược điểm rất lớn đó là việc chạy và tương tác với tầng kernel khiến cho hệ điều hành không được ổn định vì các tiến trình hay driver ở đây đều chia sẻ chung một bộ nhớ, nếu AV bị crash ở tầng này thì toàn bộ hệ thống sẽ bị lỗi màn hình xanh (BSOD) do PatchGuard sẽ gọi `KeBugCheck(0x109)` với mô tả lỗi là `CRITICAL_STRUCTURE_CORRUPTION`. Chính vì vậy nên Microsoft đã vô hiệu hoá phương thức này bằng cấm không cho sửa SSDT nữa và thay thế bằng **Kernel Callback**.

Ta đã biết sơ về kernel, vậy còn khái niệm callback nghĩa nôm na là khi một hàm `A` được gọi, nó sẽ đưa ra một thông báo hoặc `SetEvent` một flag toàn cục cho một hàm `B` khác đã đăng ký callback với nó. Và kernel callback cũng tương tự, driver của AV sẽ đăng ký callback cho một số hàm nhất định và sẽ nhận được thông báo cả trước lẫn sau khi các hàm nhất định đó được gọi. Một số callback được sử dụng rất nhiều, đặc biệt là [`PsSetCreateProcessNotifyRoutine()`](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-pssetcreateprocessnotifyroutine).

Giả sử khi một malware muốn nhân bản chính nó, thì nó sẽ phải gọi `NtCreateFile`, `CopyFile` và trong tham số của `CopyFile` có đường dẫn tới chính nó, cuối cùng là chạy những file vừa tạo. AV sẽ sử dụng callback để khi nào một trình tự các API được gọi là `NtCreateFile` -> `CopyFile` -> `CreateProcess` được gọi thì AV sẽ cảnh báo cho người dùng và huỷ tiến trình gọi các API trên. Một ví dụ khác khi malware muốn thực hiện kỹ thuật process injection thì AV sẽ bắt các API theo mẫu sau: `CreateRemoteThread` -> `VirtuallAlloc` -> `WriteMemory` -> `VirtualProtect` (Process Injection). 

Một số đăng ký callback thường được AV sử dụng theo mẫu:

- `PsSetCreateProcessNotifyRoutine`, `PsSetCreateThreadNotifyRoutine`: theo dõi các tiến trình hoặc thread được tạo
- `PsSetLoadImageNotifyRoutine`: theo dõi các DLL hay PE được thực thi hoặc được lưu vào bộ nhớ
- `ExCallbackFunction`: theo dõi các yêu cầu chỉnh sửa, xoá, tạo khoá registry

Vậy làm sao để malware vượt qua được kernel callback? Khi `PsSetCreateProcessNotifyRoutine()` được gọi, AV sẽ đăng ký một danh sách các hàm và trỏ về lại hàm xử lý trong driver của nó, malware sẽ lợi dụng điểm này và vá lại hàm xử lý của AV, ví dụ ta có hàm xử lý ban đầu như sau:

```assembly
AV_driver!HandleCallback:
mov [rsp+8], RCX
push r15
push r14
push r13,
sub rsp, 18h
...
```

Malware chỉ cần thêm một byte `0xC3`, hay `ret`, vào dưới prolog của hàm xử lý và vô hiệu hoàn toàn chức năng kể trên:

```assembly
AV_driver!HandleCallback:
mov [rsp+8], RCX
push r15
push r14
push r13
sub rsp, 18h
ret
...
```

#### Phân tích bộ nhớ tiến trình (memory inspection)

Malware có thể có từng cơ chế mã hoá cho từng chuỗi một và những cơ chế này có thể thay đổi liên tục với mỗi lần compile như stack string (Lockbit), trộn buffer với một key (Conti), ... Thường điều này sẽ khiến việc phân tích tĩnh trở nên khó hơn khi ta phải tìm và hiểu được có chế giải mã chuỗi của từng loại mã độc một, mà một chương trình AV lại không có tài nguyên và đủ "thông minh" để làm được vậy. Tuy nhiên, bất kể vì lý do gì thì malware cũng phải giải mã các chuỗi đó để chính bản thân nó có thể sử dụng trong run-time, lợi dụng điều này thì AV sẽ phân tích bộ nhớ của tiến trình và tìm ra các chuỗi khả nghi.

Để bypass cơ chế phân tích bộ nhớ, malware có thể:

1. Map một section có kích thước rất lớn vào bộ nhớ của một tiến trình bất kỳ để tăng thời gian truy vấn bộ nhớ (`MapViewOfFile`)
2. Hook cái API liên quan đến bộ nhớ
3. Áp dụng cơ chế mã hoá -> giải mã -> mã hoá lại chuỗi ngay sau khi sử dụng xong (reencrypt after decrypt)
4. Tạo và giải mã chuỗi trong heap

![Nguồn: secret.club](https://raw.githubusercontent.com/Z3r0Un1x/reports/main/img-container/process-hacker-timeline.gif)

### c. Cơ chế tự bảo vệ

Hầu hết AV hiện đại đều có cơ chế tự bảo vệ các mô-đun của nó không bị chỉnh sửa, can thiệp hoặc bị tắt đi bởi các phần mềm độc hại. Các tính năng thường thấy của cơ chế này bao gồm như:

- Các người dùng thông thường và thậm chí cả người dùng với quyền quản trị (administrator) cũng không thể tuỳ ý đóng các tiến trình đang chạy của AV bằng cách thông thường (end process của Task Manager, taskkill, ...)

- Các dịch vụ (service) của AV thường đã được cấu hình DACL nên cả người dùng thông thường hay có quyền quản trị đều không thể truy vấn thông tin hay chỉnh sửa thông số của các dịch vụ này

- Các tiến trình và dịch vụ của một số AV sẽ nằm dưới quyền quản lý của một tài khoản đặc biệt mà ta không thể truy cập hoặc truy vấn thông tin.

  ![](https://raw.githubusercontent.com/Z3r0Un1x/reports/main/img-container/2022-05-26_14-58.png)

- Đa phần các AV sẽ có một mô-đun chạy kèm để quản lý và theo dõi liên tục các tiến trình thuộc AV đó, các mô-đun này thường sẽ giao tiếp với driver của AV ở tầng kernel và bảo vệ vùng nhớ của các mô-đun khác.
- Cuối cùng là sử dụng cơ chế **P**rotected **P**rocess **L**ight (PPL) của Microsoft, cũng là cách phổ biến nhất.

#### Protected Process Light

Kể từ Windows 8.1, một hô hình bảo vệ mới ở tầng kernel được thêm vào hệ điều hành và tên của mô hình này là Protected Process Light. Cách thức hoạt động của mô hình này là Windows sẽ xét tính toàn vẹn của một tiến trình và chỉ cho phép những tiến trình được tin tưởng này chạy dưới sự kiểm soát của PPL. Vậy khi được load trong PPL, các tiến trình này sẽ được Windows bảo vệ khỏi các kỹ thuật như code injection và các cách tấn công khác khi malware có quyền administrator. Việc này hoàn toàn khả thi do **chỉ có các tiến trình trong PPL mới có thể tương tác với nhau** mà các tiến trình nằm ngoài mô hình này không thể chỉnh sửa hay giả mạo được. Nhờ vào PPL, bản thân các AV không cần phải tốn tài nguyên cho các tiến trình tự bảo vệ khác.

Kể cả với quyền SYSTEM và SeDebugPrivilege, ta cũng không thể tắt được các tiến trình thuộc PPL:

```
C:\WINDOWS\system32>whoami
nt authority\system

C:\WINDOWS\system32>whoami /priv | findstr "Debug"
SeDebugPrivilege Debug programs Enabled

C:\WINDOWS\system32>taskkill /f /im MsMpEng.exe
ERROR: The process "MsMpEng.exe" with PID 2236 could not be terminated.
Reason: Access is denied.
```

Tuy nhiên, Microsoft cũng rất rõ ràng và gắt gao trong việc cấp quyền để các chương trình được bảo vệ bằng mô hình PPL để tránh việc malware lợi dụng và cài chính nó vào PPL. Để có thể chạy một ứng dụng với PPL, các nhà cung cấp dịch vụ phải trải qua một quá trình chọn lọc (vetting process) để chứng minh phần mềm của họ có thể tin tưởng được, tiếp đến các nhà phát triển AV phải cài thêm một driver đặc biệt gọi là ELAM (Early Lauch Anti-Malware) driver và có đầy đủ chữ kỹ điện tử (Code Signing) để Microsoft Authenticode xét duyệt. Sau toàn bộ các bước trên, AV có thể sử dụng ELAM driver được cấp để thêm các tiến trình của họ vào PPL.

Để có thể bypass được PPL, giả sử ta đã có quyền SYSTEM và giờ ta muốn tắt một tiến trình PPL của AV thì do mỗi tiến trình (kể cả PPL) đều được chia quyền và xác định bằng một dạng token (Token Security Descriptor) bao gồm các SID. Một chuỗi SID của một tiến trình sẽ đại diện cho quyền và sở hữu của tiến trình đó, ví dụ như một chuỗi SID của tiến trình thuộc Windows:

![](https://raw.githubusercontent.com/Z3r0Un1x/reports/main/img-container/2022-05-26_15-55.png)

Ta có thể thấy chuỗi SID của `wininit.exe` là `S-1-5-18`, tra trong bảng RID của MSDN

![](https://raw.githubusercontent.com/Z3r0Un1x/reports/main/img-container/2022-05-26_15-57.png)

ta thấy được `wininit.exe` có quyền SYSTEM, được quản lý bởi một tài khoản đặc biệt của hệ thống và đặc biệt, `wininit.exe` cũng là một PPL (`PsProtectedSignerWinTcb-Light`). Để có thể tắt được tiến trình này thì lúc trước ta chỉ cần thay đổi SID của `wininit.exe` thành SID của một tiến trình thông thường và `wininit.exe` sẽ mất đi sự bảo vệ tư PPL.

Windows đã có bản vá cho kiểu tấn công này bằng cách thêm một ACE cho SACL là "TrustLabel" cho các PPL. Windows sẽ tìm và lọc ra các tiến trình có TrustLabel ACE và chặn quyền TOKEN_WRITE đến các tiến trình này.

Ngoài ra, một số AV cũng sử dụng PPLGuard để thêm TrustLabel ACE vào các tiến trình của bản thân để cải thiện cơ chế tự bảo vệ.

#### Mini-filter driver

Không chỉ bảo vệ các tiến trình, AV cũng cần phải chú ý đến sự thay đổi trong hệ thống file và các khoá registry của bản thân để tránh các trường hợp malware có thể thay đổi tên, chỉnh sửa dữ liệu hay xoá những dữ liệu quan trọng. Bằng cách tạo và đăng ký một mini-filter driver, AV có thể bắt và chặn các yêu cầu truy cập đến các file và khoá registry đặc biệt như: Vị trí những đối tượng whitelist, flag bật tắt các tính năng bảo vệ, tên của các file mô-đun chính, tham số của service lưu trong registry hay AV settings nói chung.

Mini-filter driver sẽ đăng ký các routine như PreCreateFile, PreWriteFile, PreSetFileInformation (`IRP_MJ_CREATE`, `IRP_MJ_WRITE` và `IRP_MJ_SET_INFORMATION`) và trả về `STATUS_ACCESS_DENIED` mỗi khi các hàm CreateFile, WriteFile, SetFileInformation có chứa tham số đến các file hay khoá registry liên quan.

```c
...
// minifilter-precreatefile.c
FLT_PREOP_CALLBACK_STATUS PreCreateFileRoutine(PFLT_CALLBACK_DATA Data, PCFLT_RELATED_OBJECTS,
	PVOID*)
{
	if (Data->Iopb->Parameters.Create.Options & FILE_DELETE_ON_CLOSE)
	{
		FileNameInfo FnIObject(Data);
		if(nullptr != FnIObject.get())
		{
			if(wcsstr(FnIObject.get()->Buffer, TEXT("ProtectedFolder")))
			{
				Data->IoStatus.Status = STATUS_ACCESS_DENIED;
				return FLT_PREOP_COMPLETE;
			}
		}
	}
	return FLT_PREOP_SUCCESS_NO_CALLBACK;
}
```

Ngoài ra, đối với các khoá registry, AV sẽ sử dụng security descriptor để cài đặt các ACE lên các khoá này (Windows Defender) và ngăn không để người dùng hay mã độc có thể tuỳ ý chỉnh sửa giá trị. Bằng cách tạo một "tài khoản ma" (không thể truy cập) trên Windows với một RID riêng biệt và sử dụng tài khoản này để chứa DACL, từ đó quản lý registry và thậm chí hệ thống file.

![](https://raw.githubusercontent.com/Z3r0Un1x/reports/main/img-container/2022-06-27_10-50.png)

Tuy nhiên cách này vẫn có thể dễ dàng bị bypass khi mã độc có quyền cao hơn Administrator (`NT AUTHORITY\SYSTEM` hoặc `BUILTIN\Administrators`) nên việc bảo vệ khoá vẫn phụ thuộc vào Mini-filter là chính.

![](https://raw.githubusercontent.com/Z3r0Un1x/reports/main/img-container/2022-06-27_11-04.png)

## III. Cách AV cách ly malware

Sau khi đã nhận diện được malware, các AV thường cho chúng ta các lựa chọn như: Xoá, Cách ly, Bỏ qua, ... một số AV mới còn có công nghệ khử mã độc nâng cao nhằm xoá đi chỉ phần đoạn mã gây hại và để lại chương trình sạch cho người dùng, thường là các file phim ảnh, crack game hoặc các phần mềm lậu khác. Ở phần này ta sẽ nói về việc AV cách ly malware như thế nào.

Việc AV cho phép ta cách ly những file được xem là malware là để phòng trường hợp nhầm lẫn (false positive) và người dùng có thể chọn phục hồi lại file bị cách ly đó hay không. Khi cách ly, phần mềm AV phải chắc chắn rằng người dùng không vô tình bấm lại và thực thi file mã độc đó nên thường chúng sẽ có một cơ chế mã hoá file hẳn hoi chứ không chỉ đơn giản là đổi phần mở rộng.

EICAR test file trước và sau khi được cách ly:

![](https://raw.githubusercontent.com/Z3r0Un1x/reports/main/img-container/2022-05-26_16-30.png)

![](https://raw.githubusercontent.com/Z3r0Un1x/reports/main/img-container/2022-05-26_16-30_1.png)

Thay đổi tên và biến đổi lại một chút:

![](https://raw.githubusercontent.com/Z3r0Un1x/reports/main/img-container/2022-05-26_16-35.png)

Ta thấy được tên file được đổi thành một dạng hash SHA1 và cả 2 file cách ly đều có phần mở đầu tương tự nhau (`0B AD 00 98 91 FD DE`), phần này có thể xem như signature của file cách ly. Để có thể khôi phục lại những file này, Windows Defender sẽ có một cơ chế decrypt riêng, đối với những loại AV khác như Kaspersky, Sophos, Malwarebytes thì các thuật toán cơ bản như XOR, RC4, ... cũng được sử dụng để mã hoá file cách ly.

## IV. Một số thông tin đáng chú ý khác

Một số tính năng đặc biệt khác của AV hiện nay bao gồm:

- Tích hợp hệ thống plugin/addon
- Tường lửa và khả năng phân tích, chặn gói tin
- Các service/daemon để quản lý hoạt động và đóng vai trò như một trình giao tiếp giữa giao diện người dùng và hệ thống xử lý lõi của AV

### a. Hệ thống plugin

Plugin hay addon là một phần nhỏ trong hệ thống quản lý và nhận diện của AV. Những plugin này được sử dụng để mở rộng thêm một số các tính năng như giải nén file (ZIP, RAR, 7z, ...), hỗ trợ unpack (UPX, VMProtect, ...), công cụ giả lập Intel x86, sandbox hay plugin đọc các file với định dạng đặc biệt như PDF, DOCX, XLSX. 

Những plugin/addon này được load trong lúc AV thực thi các tính năng liên quan bằng một cơ chế thủ công riêng biệt (mỗi AV khác nhau có cách load plugin khác nhau), và cách phổ biến nhất chính là tạo một vùng nhớ với quyền RWX trên heap, giải mã và giải nén các plugin này lên vùng nhớ vừa tạo, chỉnh sửa lại quyền của vùng nhớ thành R-X, và cuối cùng là thêm vùng nhớ chứa plugin vào danh sách thực thi. Cách này còn được biết đến là dynamic loading.

Một số dịch vụ AV có cách load plugin khác như ghép các plugin thành một file DLL (container) hoặc chia nhỏ theo từng tính năng, các DLL này sẽ được mã hoá theo một cơ chế nào đó. Ví dụ như Avira AV thường hay mã hoá toàn bộ chuỗi có trong DLL plugin và chỉ giải mã chúng khi cần thiết bằng một thuật toán XOR đơn giản với key nằm hẳn trong file DLL plugin. Hay đối với Kaspersky thì các plugin được lưu dưới dạng COFF (được mã hoá bằng thuật toán XOR-ADD và nén lại), sau đó Kaspersky sẽ dùng linker riêng của nó (các routine trong `AvpBase.dll`) để link các file COFF này lại với nhau và sử dụng.

Với cách dynamic loading, việc dịch ngược các plugin này trở nên khó hơn rất nhiều do ASLR sẽ thay đổi địa chỉ vùng nhớ lưu plugin mỗi lần AV được khởi chạy nên mọi breakpoint, tên hàm sẽ bị mất và trỏ đến một địa chỉ không hợp lệ trong bộ nhớ. Một số cách để cải thiện điểm trên đó là tắt ASLR, tuy nhiên một số AV (Sophos - `BOPS.dll`) lại có cơ chế tự điều chỉnh ASLR cho bộ nhớ của nó (và các tiến trình khác) mà không cần đến ASLR của hệ điều hành.

### b. Tường lửa

Do số lượng tăng lên đáng kể của các loại mã độc có tính lây lan trong không gian mạng, các dịch vụ AV cũng đã có biện pháp đối phó bằng cách đăng ký các mini-filter driver để hỗ trợ Windows Firewall mặc định hoặc thậm chí thay thế hoàn toàn tường lửa của Microsoft (Kaspersky Internet Security, Avast, ...).

Các tường lửa này có cơ chế hoạt động tương đồng với Windows Firewall, điểm khác biệt lớn nhất có lẽ là rule-set database (cơ sở các quy tắc) chặn và cơ chế phân tích gói tin chuyên sâu (in-depth packet analysis). Windows Firewall không thể nhận diện được các gói tin đã bị mã hoá hoặc một số mã độc có thể sử dụng những protocol hoàn toàn mới (custom) nên AV sẽ đăng ký một driver mạng sử dụng WFP (Windows Filtering Platform) hoặc tương tác trực tiếp với BFE (Base Filtering Engine) để phân tích từng gói tin một. Một số AV sử dụng điện toán đám mây (Sophos Hitman.Alert) sẽ sử dụng thêm Private Cloud-based Firewall và hoạt động theo cơ chế SaaS giúp nhận diện và xử lý gói tin triệt để hơn.

### c. Cách thức tương tác giữa  AV core và các mô-đun

Một số AV có các trình quản lý trên giao diện cửa sổ dòng lệnh (CLI/console) để hỗ trợ GUI như Avast, Comodo, ...

Các file CLI này sẽ giao tiếp với AV core thông qua mô hình client-server:

- Một file thực thi sẽ chạy dưới dạng service và bắt các yêu cầu quét, phân tích, cách ly, lưu trữ từ công cụ CLI
- Công cụ CLI sẽ có đầy đủ tính năng của phiên bản GUI và sẽ gửi các yêu cầu liên quan đến server sau đó đợi thông báo trả về từ server

Đa phần giao thức giao tiếp của mô hình này thường là truy vấn plain-text, socket, HTTP, hoặc thông qua pipe (pipe server và pipe client). Những dữ liệu truyền tải trong mô hình trên thường không được mã hoá nên việc fuzzing các lỗi hoặc lỗ hổng có trong AV rất dễ được phát hiện ở tính năng này.