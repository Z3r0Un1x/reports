# Tìm hiểu cách thức hoạt động của Antivirus

[TOC]

## I. Định nghĩa về chương trình diệt virus

Chương trình diệt virus (Antivirus hay AV) là một chương trình có nhiệm vụ tìm và ngăn chặn các loại mã độc thực thi trên thiết bị của người dùng cuối. Các AV ngày nay có thể bảo vệ người dùng khỏi các mối nguy hiểm từ Internet như ransomware, backdoor, rootkit, spyware, adware, ... Ngoài ra, một số AV còn có khả năng đảm bảo tính riêng tư của người dùng, cảnh báo các trang web lừa đảo hay thậm chí phát hiện được các cuộc tấn công của những nhóm APT.

Một số sản phẩm, nhà cung cấp AV phổ biến hiện nay như: Avast, ESET, Kaspersky, Microsoft (Windows Defender), ...

## II. Cách thức hoạt động cơ bản của AV

Về cách thức hoạt động thì AV có những mô-đun chính sau:

- Quét và nhận diện mã độc tĩnh (static detection)
- Nhận diện hành vi theo thời gian thực (Real-time protection)
- Cơ chế tự bảo vệ (Self-protection module)

Biểu diễn hướng hoạt động của AV cơ bản như sau:

![](https://raw.githubusercontent.com/Z3r0Un1x/reports/main/img-container/2022-05-26_12-56.png)

### a. Nhận diện mã độc tĩnh

#### Mã băm (File hashing)

##### Khái niệm

Đây là phương pháp lâu đời và truyền thống nhất, bằng cách sử dụng các thuật toán băm như MD5, SHA1, SHA256 (phổ biến), SHA512; AV có thể kiểm tra một chương trình hay một đoạn mã và đối chiếu hash của chúng với database chứa những mã hash của các chương trình độc hại đã được tìm thấy trước đó.

##### Tự biến đổi code để bypass file hashing

Khi sử dụng cách nhận diện này, AV có thể nhanh chóng phát hiện các đoạn mã độc từ Internet. Tuy nhiên, cách này cũng có lỗ hổng khi malware ngày nay thường có cơ chế tự biến đổi (polymorphic).

Ví dụ như hàm `morphcode` trong ransomware Conti V3.7:

![](https://raw.githubusercontent.com/Z3r0Un1x/reports/main/img-container/2022-05-26_12-12.png)

Khi ransomware được chạy hoặc biên dịch thì nó sẽ sinh ra một biến rác ngẫu nhiên dựa trên [hàm sinh tuyến tính](https://www.cplusplus.com/reference/random/linear_congruential_engine/linear_congruential_engine/) với giá trị thuộc khoảng từ 0 đến MAX_INT32 (`0x7FFFFF`), tiếp đó biến trên sẽ không bị tối ưu hoá đi (volatile) và sẽ liên tục thay chính nó dẫn đến thay đổi cả signature khiến cho việc nhận diện đoạn mã độc này khó khăn hơn với AV.

#### Quét chuỗi

##### Khái niệm

AV có thể nhận diện ban đầu (fingerprinting) malware bằng cách kiểm tra tên file, tên cửa sổ (window title), vị trí của file xem có khả nghi hay không trước. Đối với các loại malware, mã độc phổ biến thì khi được cài đặt sẽ có những tên file đặc trưng, dựa vào đây AV có thể xác định và lưu ý những đối tượng này.

```
Image name contains "Loadlibr"
Image name contains "Rng "
Image name contains "\A0\E7\FF\FF\FF\81"
Image name contains "RNG "
Image name contains "\90\E5\43\55"
Image name contains "2.6.ex"
Image name contains "TempFile.exe"
Image name contains "mimikat"
```

Tương tự với tên cửa sổ, AV sẽ mở và duyệt qua từng cửa sổ hiện hành để kiểm tra tên của chúng có nằm trong blacklist hay không:

```c
        // DOES WINDOW TITLE MATCH ANY OF THE BLACKLISTED TITLES?
        if (!contains(window_title_report.window_title, "CheatAut") &&
            !contains(window_title_report.window_title, "pubg_kh") &&
            !contains(window_title_report.window_title, "conl -") &&
            !contains(window_title_report.window_title, "PerfectA") &&
            !contains(window_title_report.window_title, "AIMWA") &&
            !contains(window_title_report.window_title, "PUBG AIM") &&
            !contains(window_title_report.window_title, "HyperChe"))
            continue;
```

Kiểm tra vị trí của các file thực thi tại một số điểm đáng ngờ:

```
\Desktop\
\Temp\
\FileRec
\Documents\
\Downloads\
\Roaming\
```

Một số AV sẽ nhận diện malware theo các chuỗi có trong bộ nhớ của chúng, ta cũng sẽ lấy ví dụ ransomware Conti thì nó sẽ có một đoạn chuỗi được hardcode trực tiếp vào trong chương trình để tạo một singleton mutex:

![](https://raw.githubusercontent.com/Z3r0Un1x/reports/main/img-container/2022-05-27_14-27.png)

Bằng cách phân tích hàm mã hoá OBFA, ta có thể có được bản gốc của mutex này và AV sẽ lưu chuỗi trên vào trong database để mỗi khi mutex được khởi tạo hoặc bất cứ chương trình nào có chứa chuỗi tương ứng trong bộ nhớ thì AV cũng có thể nhận diện và ngăn chặn sớm hơn.

Ngoài ra còn có một cách khác mà AV sử dụng thay vì tìm trực tiếp từng chuỗi vì các mutex này có thể bị thay đổi dễ dàng, đó là sử dụng string pattern (chuỗi có quy tắc). Sau đây là ví dụ của một chương trình DRM tìm các chuỗi có trong các phần mềm gian lận (HackTool) bằng string pattern:

```
[05 18] ojects\PUBGChinese
[05 17] BattleGroundsPrivate_CheatESP
[05 17] [%.0fm] %s
[05 3E] \00\00\00\00Neck\00\00\00\00Chest\00\00\00\00\00\00\00Mouse 1\00
[05 3F] PlayerESPColor
[05 40] Aimbot: %d\00\2D\3E\20\41
[05 36] HackMachine
[05 4A] VisualHacks.net
[05 50] \3E\23\2F\65\3E\31\31\4E\4E\56\3D\42\76\28\2A\3A\2E\46\3F\75\75\23\28\67\52\55\2E\6F\30\58\47\48
[05 4F] DLLInjection-master\\x64\\Release\\
[05 52] NameESP
[05 48] Skullhack
[05 55] .rdata$zzzdbg
[05 39] AimBot
[05 39] \EB\49\41\80\3C\12\3F\75\05\C6\02\3F\EB\38\8D\41\D0\0F\BE\C9\3C\09\77\05\83\E9\30\EB\06\83\E1\DF
[05 5F] \55\E9
[05 5F] \57\E9
[05 5F] \60\E9
[05 68] D3D11Present initialised
[05 6E] [ %.0fM ]
[05 74] [hp:%d]%dm
[05 36] \48\83\64\24\38\00\48\8D\4C\24\58\48\8B\54\24\50\4C\8B\C8\48\89\4C\24\30\4C\8B\C7\48\8D\4C\24\60
[05 36] \74\1F\BA\80\00\00\00\FF\15\60\7E\00\00\85\C0\75\10\F2\0F\10\87\80\01\00\00\8B\87\88\01\00\00\EB
[05 36] \40\F2\AA\15\6F\08\D2\89\4E\9A\B4\48\95\35\D3\4F\9CPOSITION\00\00\00\00COL
[05 7A] \FF\E0\90
[05 79] %s\00\00%d\00\00POSITION\00\00\00\00COLOR\00\00\00\00\00\00\00
[05 36] \8E\85\76\5D\CD\DA\45\2E\75\BA\12\B4\C7\B9\48\72\11\6D\B9\48\A1\DA\A6\B9\48\A7\67\6B\B9\48\90\2C
[05 8A] \n<assembly xmlsn='urn:schemas-mi
```

Hiện nay các chương trình AV cũng cài đặt các tính năng tìm kiếm theo chuỗi trong cơ chế hoạt động của mình, đặc biệt là sự góp mặt của YARA. Các quy tắc YARA rất dễ đọc hiểu và ứng dụng nên các chuyên gia thường sử dụng YARA để nhận diện đa phần các loại mã độc và những biến thể của chúng một cách nhanh chóng trong khi phương pháp hashing truyền thống chỉ nhận diện được từng loại mã độc một. Bằng cách chỉ cần tìm ra một quy luật, cấu trúc hay một offset có dữ liệu không đổi nhất định, YARA có thể biết được các biến thể mà không cần phải tiến hành băm từng file.

Giả sử ta có một file EICAR như sau:

![](https://raw.githubusercontent.com/Z3r0Un1x/reports/main/img-container/2022-05-27_14-48.png)

Khi phân tích, AV không cần phải đọc từng byte một hoặc hash toàn bộ file mà nó chỉ cần lựa ra chuỗi byte `45 49 43 41 52` và xác định được đây là loại file nào thuộc chủng malware nào. Và khi mã độc thêm hay chỉnh sửa lại đoạn byte trên, AV vẫn có thể sử dụng wildcard trong YARA để xử lý. Ví dụ khi đoạn byte trên có thể được đổi thành `45 00 00 41 52` hay `45 10 00 41 52` thì với đoạn string pattern là `{45 ?? ?? 41 52}` thì AV có thể nhận diện được. Kể cả nếu malware có thêm một lượng byte nhất định như `45 00 00 01 02 03 49 43 41 52`, với quy tắc YARA `{45 [1-10] 49 43 41 52}` thì ta vẫn có thể nhận dạng được đoạn mã độc trên.

##### Bypass bằng kỹ thuật stack string

Với kiểu nhận dạng này thì malware đã phát triển thêm kỹ thuật mới để giấu đi các đoạn chuỗi quan trọng.

Stack string: Malware sẽ không lưu chuỗi dưới dạng một buffer liên tục mà nó sẽ đẩy 1 hoặc 4 byte lần lượt có trong chuỗi đó lên stack, các byte này đã được mã hoá ở giai đoạn compile bằng các thuật toán từ đơn giản (XOR, RC4, cộng, trừ, ...) cho đến các thuật toán tự tạo phức tạp, sau đó malware sẽ giải mã các byte này ở vị trí tương ứng. Ví dụ như ransomware Lockbit sử dụng stack string để giấu tên của các module DLL mà nó gọi:

![](D:/repos/reports/img-container/2022-06-29_08-42.png)



#### Import hashing

##### Khái niệm

Mỗi file thực thi (PE) sẽ có một **I**mport **A**ddress **T**able (IAT) để chương trình có thể tìm và gọi các hàm từ những thư viện khác nhau. AV có thể hash IAT và biết được các mã độc có phải là biến thể từ một nguồn đã được xác định hay không. Thì thuật toán của Import hasing như sau:

- Mở IAT của PE và map lại toàn bộ số thứ tự của từng hàm (do có một số thư viện như `oleaut32`,` ws2_32`, `wsock32` chỉ có số thứ tự chứ không có tên hàm cụ thể), tên hàm và cả các DLL chứa những hàm này
- Chuyển thông tin vừa map ở trên thành dạng viết thường (lowercase)
- Sắp xếp lại các hàm theo thứ tự và sinh ra một đoạn hash MD5 dựa trên thông tin vừa tổng hợp

Vậy là sau khi hash IAT thì AV có thể đối chiếu với các hash IAT của malware khác trong database.

> **Lưu ý:** Đối với những mã độc viết bằng .NET thì import hashing sẽ không sử dụng được nên ta sẽ chuyển qua hash các namespace, kiểu dữ liệu. Cách này được gọi là TypeRefHash.

Demo:

```c++
HRESULT IatHashing(PBYTE const pbImageBuffer, size_t const SizeOfImage, uint32_t& hash, size_t* SizeOfHash)
{
	HRESULT hr = S_OK;
	PIMAGE_DOS_HEADER pDosHeader = nullptr;
	PIMAGE_NT_HEADERS pNtHeaders = nullptr;
	PIMAGE_IMPORT_DESCRIPTOR importDescriptor = NULL;
	IMAGE_DATA_DIRECTORY importsDirectory = { NULL };
	LPCSTR lptLibraryName = { NULL };
	HMODULE hmLibrary = nullptr;
	PIMAGE_IMPORT_BY_NAME functionName = nullptr;
	::std::vector<::std::string> v_ImportedFunctions;
	::std::vector<::std::string> v_Dlls;
	::std::vector<::std::string> v_Merge;
	PIMAGE_SECTION_HEADER pSectionHeader = { NULL };
	PIMAGE_THUNK_DATA originalFirstThunk = NULL, firstThunk = NULL;
	CHAR szConvertBuffer[_MAX_U64TOSTR_BASE10_COUNT] = { NULL };
	::std::string ImpString = "";

	if (nullptr == pbImageBuffer || NULL == SizeOfImage)
	{
		hr = E_INVALIDARG;
		DEBUG_PRINT(TEXT("[ERROR]::%s->%s invalid one or more arguments: 0x%08lx"), _FASTNAME_(IatHashing), _FASTNAME_(E_INVALIDARG), hr);
		goto Cleanup;
	}

	pDosHeader = PIMAGE_DOS_HEADER(pbImageBuffer);
	if (NULL == pDosHeader)
	{
		hr = E_INVALIDARG;
		DEBUG_PRINT(TEXT("[ERROR]::%s->%s has zero data. Please verify image buffer."), _FASTNAME_(IatHashing), _FASTNAME_(PIMAGE_DOS_HEADER));
		goto Cleanup;
	}

	pNtHeaders = PIMAGE_NT_HEADERS(DWORD_PTR(pbImageBuffer) + pDosHeader->e_lfanew);
	pSectionHeader = IMAGE_FIRST_SECTION(pNtHeaders);
	importsDirectory = pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
	importDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)(Rva2Offset(importsDirectory.VirtualAddress, pSectionHeader, pNtHeaders) + (DWORD_PTR)pbImageBuffer);

	while (importDescriptor->Name != NULL)
	{
		lptLibraryName = (LPCSTR)(Rva2Offset(importDescriptor->Name, pSectionHeader, pNtHeaders) + (DWORD_PTR)pbImageBuffer);
		hmLibrary = LoadLibraryA(lptLibraryName);
		if (hmLibrary)
		{
			v_Dlls.push_back(lptLibraryName);
			originalFirstThunk = (PIMAGE_THUNK_DATA)((DWORD_PTR)pbImageBuffer + Rva2Offset(importDescriptor->OriginalFirstThunk, pSectionHeader, pNtHeaders));
			firstThunk = (PIMAGE_THUNK_DATA)((DWORD_PTR)pbImageBuffer + Rva2Offset(importDescriptor->FirstThunk, pSectionHeader, pNtHeaders));
			while (originalFirstThunk->u1.AddressOfData != NULL)
			{
				functionName = (PIMAGE_IMPORT_BY_NAME)((DWORD_PTR)pbImageBuffer + Rva2Offset(DWORD(originalFirstThunk->u1.AddressOfData), pSectionHeader, pNtHeaders));
				if (::std::string(functionName->Name).compare("") == 0)
				{
					_itoa_s(functionName->Hint, szConvertBuffer, _countof(szConvertBuffer), 10);
					v_ImportedFunctions.push_back(::std::string(szConvertBuffer));
				}
				else
					v_ImportedFunctions.push_back(::std::string(functionName->Name));

				++originalFirstThunk;
				++firstThunk;
			}
		}
		importDescriptor++;
	}

	for (size_t i = 0; i < v_Dlls.size(); i++)
	{
		::std::transform(
			v_Dlls.at(i).begin(),
			v_Dlls.at(i).end(),
			v_Dlls.at(i).begin(),
			::tolower
		);
	}
	for (size_t i = 0; i < v_ImportedFunctions.size(); i++)
	{
		::std::transform(
			v_ImportedFunctions.at(i).begin(),
			v_ImportedFunctions.at(i).end(),
			v_ImportedFunctions.at(i).begin(),
			::tolower
		);
	}
	SortVectorAlphabet(v_Dlls);
	SortVectorAlphabet(v_ImportedFunctions);
	v_Merge.reserve(v_Dlls.size() + v_ImportedFunctions.size());
	v_Merge.insert(v_Merge.end(), v_Dlls.begin(), v_Dlls.end());
	v_Merge.insert(v_Merge.end(), v_ImportedFunctions.begin(), v_ImportedFunctions.end());

	for (size_t i = 0; i < v_Merge.size(); i++)
	{
		ImpString += v_Merge.at(i);
		//DEBUG_PRINT(TEXT("%s"), v_Merge.at(i).c_str());
	}
	hash = crc32(ImpString.c_str(), ImpString.size());
Cleanup:
	return hr;
}
```

##### Bypass bằng API Hashing

Malware thường sử dụng kỹ thuật API hashing để che giấu những API quan trọng hoặc có trong blacklist của AV. Kỹ thuật này có cơ chế hoạt động như sau:

1. Hash tên API mà malware muốn gọi

   ```pseudocode
   $hashed_WriteProcessMemory = md5("WriteProcessMemory")
   ```

2. Load DLL chứa API cần gọi vào bộ nhớ

   ```pseudocode
   $lib = LoadLibrary("Kernel32.dll")
   ```

3. Hash lần lượt từng tên API có trong DLL vừa load và so sánh với hash của API cần gọi

4. Nếu hai hash bằng nhau, gọi API đó thông qua RVA

   ```pseudocode
   foreach $elem in $lib.AllExportedFunctions:
   	if(md5($elem.Name) == $hashed_WriteProcessMemory):
   		$WriteProcessMemoryOriginalAddr = $elem.RVA
   		CallAPViaRVA($WriteProcessMemoryOriginalAddr, arg1, arg2, ...)
   		return
   ```

Cách thứ hai là malware có thể gọi API của nó thông qua syscall trực tiếp:

```assembly
;    NtCreateFile(&file, GENERIC_WRITE | SYNCHRONIZE, &atrs, &iostat, NULL,
;             FILE_ATTRIBUTE_NORMAL, 0, FILE_OVERWRITE_IF,
;             FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);
.code
	SysNtCreateFile proc
			mov r10, rcx
			mov eax, 55h
			syscall
			ret
	SysNtCreateFile endp
end

int __cdecl main()
{
    SysNtCreateFile(&file, GENERIC_WRITE | SYNCHRONIZE, &atrs, &iostat, NULL,
             FILE_ATTRIBUTE_NORMAL, 0, FILE_OVERWRITE_IF,
             FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);
}
```

#### TypeRefHash (TRH)

Cũng tương tự như IAT hashing, TRH sẽ hash các namespace và kiểu dữ liệu của một chương trình .NET. Lý do tại sao import hashing lại không hoạt động được là vì các chương trình .NET chỉ sử dụng gần như là chỉ một mình `mscoree.dll`.

Trong khi các PE thông thường gọi API từ các DLL bằng IAT, .NET lưu những namespace và kiểu dữ liệu tham chiếu (referenced type) của nó ở một bảng, tạm gọi là Metadata table và cách bố trí dữ liệu trong bảng này cũng khá giống IAT.

![](https://raw.githubusercontent.com/Z3r0Un1x/reports/main/img-container/2022-05-27_14-49.png)

Để tính được hash của một bảng TypeRef:

- Sắp xếp lại toàn bộ bảng theo TypeNamespace trước và sau đó là sắp xếp theo TypeName
- Nối TypeNamespace và TypeName lại bằng dấu `-`, đối với những TypeName không có namespace thì chuỗi sẽ bắt đầu bằng ký tự `-`. Ví dụ `DebuggingModes` không thuộc namespace nào nên chuỗi nối của nó sẽ là `-DebuggingModes`
- Nối tất cả các chuỗi trên bằng dấu `,` và tính hash của chuỗi này (MD5/SHA1/SHA256)

### b. Phân tích hành vi của chương trình

#### Phân tích bộ nhớ tiến trình (memory inspection)

##### Khái niệm

Malware có thể có từng cơ chế mã hoá cho từng chuỗi một và những cơ chế này có thể thay đổi liên tục với mỗi lần compile như stack string (Lockbit), trộn buffer với một key (Conti), ... Thường điều này sẽ khiến việc phân tích tĩnh trở nên khó hơn khi ta phải tìm và hiểu được có chế giải mã chuỗi của từng loại mã độc một, mà một chương trình AV lại không có tài nguyên và đủ "thông minh" để làm được vậy. Tuy nhiên, bất kể vì lý do gì thì malware cũng phải giải mã các chuỗi đó để chính bản thân nó có thể sử dụng trong run-time, lợi dụng điều này thì AV sẽ phân tích bộ nhớ của tiến trình và tìm ra các chuỗi khả nghi.

##### Cách bypass

Để bypass cơ chế phân tích bộ nhớ, malware có thể:

1. Map một section có kích thước rất lớn vào bộ nhớ của một tiến trình bất kỳ để tăng thời gian truy vấn bộ nhớ (`MapViewOfFile`)

   ![Nguồn: secret.club](https://raw.githubusercontent.com/Z3r0Un1x/reports/main/img-container/process-hacker-timeline.gif)

2. Hook các API liên quan đến bộ nhớ

3. Áp dụng cơ chế mã hoá -> giải mã -> mã hoá lại chuỗi ngay sau khi sử dụng xong (re-encrypt after decrypt)

4. Tạo và giải mã chuỗi trong heap

5. Do việc phân tích bộ nhớ tốn nhiều tài nguyên và thời gian, nên AV chỉ kiểm soát bộ nhớ của tiến trình trong một khoảng thời gian nhất đinh. Vì vậy, malware sẽ kéo dài thời gian thực thi và giải mã chuỗi bằng các hàm `Sleep`, `SleepEx`

#### API hooking và Kernel callback

##### API Hooking

Đối với userland, AV có các kỹ thuật để phân tích hành vi của chương trình như Win32 API hooking, bằng cách chuyển các lời gọi hàm API qua một chuỗi các thủ tục trước khi cho phép chương trình thực thi, AV có thể biết được toàn bộ giá trị tham số, thông tin của người gọi hàm API để từ đó có biết được những đoạn mã độc ở đâu, thuộc tiến trình nào.

###### Bypass API Hooking

Tuy nhiên sau một thời gian thì malware lại gọi Native API trực tiếp từ `ntdll.dll` để bypass Win32 API hooking, thì lúc này AV lại tiếp tục hook các hàm có trong `ntdll.dll`. Các tiến trình malware đã tiếp tục sử dụng các kỹ thuật khác như API unhooking, custom lại syscall, ...

Ví dụ đối với syscall của `NtCreateFile`:

![](https://raw.githubusercontent.com/Z3r0Un1x/reports/main/img-container/2022-05-26_13-26.png)

Malware có thể sao chép lại đoạn syscall trên và tạo một hàm cùng signature với `NtCreateFile` để gọi và bypass được hook của AV.

Cách thứ hai là API unhooking thì malware có thể map lại bản gốc của `ntdll.dll` vào trong bộ nhớ rồi ghi đè .text section của bản gốc lên `ntdll.dll` bị hook.

![Nguồn: Internet](https://raw.githubusercontent.com/Z3r0Un1x/reports/main/img-container/image.png)

Sau đó malware chỉ cần cài lại cơ chế bảo vệ của vùng nhớ (sử dụng `VirtualProtect`) của `ntdll.dll` là đã có thể unhook toàn bộ API và sử dụng cho mục đích riêng.

##### Kernel Callback

Để đối phó với những vấn đề mới nêu trên, AV đã chuyển sang tầng kernel và vá lại (patching) System Service Dispatch Table (SSDT), sau đó chuyển tiếp hướng thực thi của malware về lại các mô-đun của AV. Cho dễ hiểu thì SSDT sẽ chứa toàn bộ ID của các syscall, giả sử với hàm `NtCreateFile` như ở ví dụ vừa rồi thì nó sẽ có ID là `0x55`, khi tra ID này trong SSDT sẽ trỏ đến vị trí của System Service Descriptor Table (KeServiceDescriptorTable) được export trong `Ntoskrnl.exe`.

![Nguồn: Internet](https://raw.githubusercontent.com/Z3r0Un1x/reports/main/img-container/a.png)

AV sẽ chỉnh lại vị trí của `NtCreateFile` trong SSDT vào một hàm thuộc bản thân nó để bắt đầu phân tích thay vì dẫn đến đúng vùng nhớ chứa bản gốc của hàm vừa gọi. Cách làm này có nhược điểm rất lớn đó là việc chạy và tương tác với tầng kernel khiến cho hệ điều hành không được ổn định vì các tiến trình hay driver ở đây đều chia sẻ chung một bộ nhớ, nếu AV bị crash ở tầng này thì toàn bộ hệ thống sẽ bị lỗi màn hình xanh (BSOD) do PatchGuard sẽ gọi `KeBugCheck(0x109)` với mô tả lỗi là `CRITICAL_STRUCTURE_CORRUPTION`. Chính vì vậy nên Microsoft đã vô hiệu hoá phương thức này bằng việc cấm không cho sửa SSDT nữa và thay thế bằng **Kernel Callback**.

Ta đã biết sơ về kernel, vậy còn khái niệm callback nghĩa nôm na là khi một hàm `A` được gọi, nó sẽ đưa ra một thông báo hoặc `SetEvent` một flag toàn cục cho một hàm `B` khác đã đăng ký callback với nó. Và kernel callback cũng tương tự, driver của AV sẽ đăng ký callback cho một số hàm nhất định và sẽ nhận được thông báo cả trước lẫn sau khi các hàm nhất định đó được gọi. Một số callback được sử dụng rất nhiều, đặc biệt là [`PsSetCreateProcessNotifyRoutine()`](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-pssetcreateprocessnotifyroutine).

Giả sử khi một malware muốn nhân bản chính nó, thì nó sẽ phải gọi `NtCreateFile`, `CopyFile` và trong tham số của `CopyFile` có đường dẫn tới chính nó, cuối cùng là chạy những file vừa tạo. AV sẽ sử dụng callback để khi nào một trình tự các API được gọi là `NtCreateFile` -> `CopyFile` -> `CreateProcess` được gọi thì AV sẽ cảnh báo cho người dùng và huỷ tiến trình gọi các API trên. Một ví dụ khác khi malware muốn thực hiện kỹ thuật process injection thì AV sẽ bắt các API theo mẫu sau: `CreateRemoteThread` -> `VirtuallAlloc` -> `WriteMemory` -> `VirtualProtect` (Process Injection). 

Một số đăng ký callback thường được AV sử dụng theo mẫu:

- `PsSetCreateProcessNotifyRoutine`, `PsSetCreateThreadNotifyRoutine`: theo dõi các tiến trình hoặc thread được tạo
- `PsSetLoadImageNotifyRoutine`: theo dõi các DLL hay PE được thực thi hoặc được lưu vào bộ nhớ
- `ExCallbackFunction`: theo dõi các yêu cầu chỉnh sửa, xoá, tạo khoá registry

###### Patch hàm detour của AV để bypass kernel callback

Vậy làm sao để malware vượt qua được kernel callback? Khi `PsSetCreateProcessNotifyRoutine()` được gọi, AV sẽ đăng ký một danh sách các hàm và trỏ về lại hàm xử lý trong driver của nó, malware sẽ lợi dụng điểm này và vá lại hàm xử lý của AV, ví dụ ta có hàm xử lý ban đầu như sau:

```assembly
AV_driver!HandleCallback:
mov [rsp+8], RCX
push r15
push r14
push r13,
sub rsp, 18h
...
```

Malware chỉ cần thêm một byte `0xC3`, hay `ret`, vào dưới prolog của hàm xử lý và vô hiệu hoàn toàn chức năng kể trên:

```assembly
AV_driver!HandleCallback:
mov [rsp+8], RCX
push r15
push r14
push r13
sub rsp, 18h
ret
...
```

#### Event Tracing for Windows - ETW

##### Khái niệm

Kể từ phiên bản Windows 10 1809, Microsoft đã thêm tính năng Event Tracing để phát hiện APC code injection.

> APC - asynchronous procedure call có thể hiểu đơn giản là một hàm được thực thi bất đồng bộ trong một thread nhất định và mỗi thread sẽ quản lý các APCs của nó theo cơ chế hàng chờ, hay còn được biết đến là APC queue. APC được tạo bởi các tiến trình thông thường được gọi là user-mode APC và đối với APC được hệ thống quản lý thì được gọi là kernel APC. Tiến trình bất kỳ có thể đưa các APC của bản thân vào danh sách APC queue của thread ngang hoặc dưới quyền của nó và malware lợi dụng điểm này để thực hiện shellcode injection.

Lấy ví dụ khi muốn dump bộ nhớ của tiến trình `lsass.exe`, attacker phải gọi một API là `ReadVirtualMemory` và để bypass API hooking của AV thì ta phải gọi `ReadVirtualMemory` trực tiếp qua syscall để chuyển từ user-mode API thành kernel-mode API và sử dụng một số phương pháp unhook khác. Có thể thấy bên dưới, trước khi gọi `NtReadVirtualMemory`, đoạn code sẽ kiểm tra quyền của tiến trình bằng cách so sánh `SharedUserData+0x308` (`ULONG SystemCall` trong struct `KI_USER_SHARED_DATA`) với `1`, nếu không thoả sẽ chạy đến `ntdll!NtReadVirtualMemory+0x15` và thực thi ngắt `int 2Eh`, ngắt này sẽ gọi `ntdll!NtReadVirtualMemory` ở tầng kernel.

```
0:002> uf ntdll!NtReadVirtualMemory
ntdll!NtReadVirtualMemory:
00007fff`11e5c890 4c8bd1          mov     r10,rcx
00007fff`11e5c893 b83f000000      mov     eax,3Fh
00007fff`11e5c898 f604250803fe7f01 test    byte ptr [SharedUserData+0x308 (00000000`7ffe0308)],1
00007fff`11e5c8a0 7503            jne     ntdll!NtReadVirtualMemory+0x15 (00007fff`11e5c8a5)  Branch

ntdll!NtReadVirtualMemory+0x12:
00007fff`11e5c8a2 0f05            syscall
00007fff`11e5c8a4 c3              ret

ntdll!NtReadVirtualMemory+0x15:
00007fff`11e5c8a5 cd2e            int     2Eh
00007fff`11e5c8a7 c3              ret
```

và trong các phiên bản Windows trước 1809, `ReadVirtualMemory` sau đó sẽ được gọi thẳng từ kernel và thực hiện đúng nhiệm vụ của nó.

```
lkd> uf nt!NtReadVirtualMemory
nt!NtReadVirtualMemory:
fffff801`25a22a80 4883ec38        sub     rsp,38h
fffff801`25a22a84 488b442460      mov     rax,qword ptr [rsp+60h]
fffff801`25a22a89 c744242810000000 mov     dword ptr [rsp+28h],10h
fffff801`25a22a91 4889442420      mov     qword ptr [rsp+20h],rax
fffff801`25a22a96 e815000000      call    nt!MiReadWriteVirtualMemory (fffff801`25a22ab0)
fffff801`25a22a9b 4883c438        add     rsp,38h
fffff801`25a22a9f c3              ret
```

Tuy nhiên trong các phiên bản gần đây (từ 1809 trở đi), kernel sẽ kiểm tra xem `ReadVirtualMemory` được gọi với quyền nào và ngăn không cho API này đọc bộ nhớ của các tiến trình được bảo vệ.

```
lkd> uf nt!NtReadVirtualMemory
nt!MiReadWriteVirtualMemory+0x1ce:
fffff801`25a22c7e 48897c2428      mov     qword ptr [rsp+28h],rdi
fffff801`25a22c83 4c89642420      mov     qword ptr [rsp+20h],r12
fffff801`25a22c88 448bca          mov     r9d,edx
fffff801`25a22c8b 4d8bc6          mov     r8,r14
fffff801`25a22c8e 498bd2          mov     rdx,r10
fffff801`25a22c91 8bce            mov     ecx,esi
fffff801`25a22c93 ebe8e8f70200      call    nt!EtwTiLogReadWriteVm (fffff801`25a52480)
fffff801`25a22c98 eb90            jmp     nt!MiReadWriteVirtualMemory+0x17a (fffff801`25a22c2a) 
```

Có thể thấy hàm `nt!EtwTiLogReadWriteVm` được gọi để log lại thông tin của hàm `NtReadVirtualMemory` và quyền của tiến trình gọi API này:

```
lkd> uf nt!EtwTiLogReadWriteVm
nt!EtwTiLogReadWriteVm:
fffff801`25a52480 48895c2420      mov     qword ptr [rsp+20h],rbx
fffff801`25a52485 894c2408        mov     dword ptr [rsp+8],ecx
fffff801`25a52489 55              push    rbp
fffff801`25a5248a 56              push    rsi
fffff801`25a5248b 57              push    rdi
...
nt!EtwTiLogReadWriteVm+0x175667:
...
fffff801`25bc7b4d e8161796ff      call    nt!EtwpTiFillProcessIdentity (fffff801`25529268)
fffff801`25bc7b52 4403c8          add     r9d,eax
fffff801`25bc7b55 488d8db0000000  lea     rcx,[rbp+0B0h]
fffff801`25bc7b5c 418bc1          mov     eax,r9d
fffff801`25bc7b5f ba08000000      mov     edx,8
fffff801`25bc7b64 4803c0          add     rax,rax
fffff801`25bc7b67 41ffc1          inc     r9d
fffff801`25bc7b6a 4533c0          xor     r8d,r8d
fffff801`25bc7b6d 8364c44c00      and     dword ptr [rsp+rax*8+4Ch],0
fffff801`25bc7b72 48894cc440      mov     qword ptr [rsp+rax*8+40h],rcx
fffff801`25bc7b77 488d8db8000000  lea     rcx,[rbp+0B8h]
fffff801`25bc7b7e 8954c448        mov     dword ptr [rsp+rax*8+48h],edx
fffff801`25bc7b82 418bc1          mov     eax,r9d
fffff801`25bc7b85 4803c0          add     rax,rax
fffff801`25bc7b88 8364c44c00      and     dword ptr [rsp+rax*8+4Ch],0
fffff801`25bc7b8d 48894cc440      mov     qword ptr [rsp+rax*8+40h],rcx
fffff801`25bc7b92 41ffc1          inc     r9d
fffff801`25bc7b95 488b0de4d0c6ff  mov     rcx,qword ptr [nt!EtwThreatIntProvRegHandle (fffff801`25834c80)]
fffff801`25bc7b9c 8954c448        mov     dword ptr [rsp+rax*8+48h],edx
fffff801`25bc7ba0 488d442440      lea     rax,[rsp+40h]
fffff801`25bc7ba5 488bd3          mov     rdx,rbx
fffff801`25bc7ba8 4889442420      mov     qword ptr [rsp+20h],rax
fffff801`25bc7bad e8ce0e8aff      call    nt!EtwWrite (fffff801`25468a80)
fffff801`25bc7bb2 90              nop
fffff801`25bc7bb3 e939a9e8ff      jmp     nt!EtwTiLogReadWriteVm+0x71 (fffff801`25a524f1)  Branch

```

Nếu để ý thì  `EtwTiLogReadWriteVm` cũng sẽ điền thông tin vào một handle với tên gọi là `nt!EtwThreatIntProvRegHandle` và handle đặc biệt này cũng được gọi trong các hàm Event Tracing khác như:

- `EtwTiLogInsertQueueUserApc`: Kiểm tra và lưu lại thông tin khi tiến trình gọi các user-mode API liên quan đến APC queue
- `EtwTiLogAllocExecVm`,`EtwTiLogProtectExecVm`: Tương tự như trên đối với hàm `VirtualAlloc`, `VirtualProtect`
- `EtwTiLogReadWriteVm`: Các hàm liên quan như `ReadMemory`, `WriteMemory`
- ...

> **Lưu ý:** Mặc dù trong tên của nt!EtwThreatIntProvRegHandle có chữ "handle" nhưng đối tượng này không phải là một handle thật sự. EtwThreatIntProvRegHandle có kiểu như một struct đặc biệt giống như REGHANDLE trỏ đến ETW_REGISTRATION_ENTRY.

Ta thấy handle ETW này nắm giữ hầu như toàn bộ các API có khả năng bị sử dụng trong mã độc với các kỹ thuật phổ biến như process hollowing, process injection, ... Và sau khi được khởi tạo giá trị, handle `nt!EtwThreatIntProvRegHandle` và handle này sẽ truyền đến cho các tiến trình có đăng ký callback ETW và các hàm callback này sẽ đọc rồi sau đó so sánh giá trị trong `nt!EtwThreatIntProvRegHandle` với bảng event descriptors.

![](D:\repos\reports\img-container\event-descriptors.png)

Đây là cách Windows Defender và một số AV sử dụng ETW để nhận diện các loại mã độc sử dụng syscall để leo quyền, dump bộ nhớ, thực thi APC injection để bypass các cơ chế nhận diện thông thường. ETW rất dễ ứng dụng vào các tính năng nhận diện của AV vì:

- Mọi event của hệ thống đều thông qua ETW
- Dễ dàng tuỳ chỉnh (tạo, chỉnh sửa event)
- Tốc độ nhanh
- Khả năng lưu trữ lớn (lưu trữ trên 50,000 event với 1000 provider khác nhau)
- Không cần phải viết driver
- Không cần reboot

##### Bypass ETW

Tuy nhiên attacker vẫn có thể thoát được ETW bằng các cách:

1. Patch trực tiếp `NTDLL.dll` trong bộ nhớ và sửa return code của `EtwEventWrite` thành `S_OK` (0) để vô hiệu tính năng tạo event của tiến trình:

   ![](D:\repos\reports\img-container\etw-patch-ntdll.jpg)

   cách này rất đơn giản nhưng cũng rất dễ bị phát hiện do ta vẫn sử dụng user-mode API tuy nhiên nó vẫn có thể chạy được trong một số trường hợp nhất định

2. Giả sử ta có thể chạy code ở Ring0 thông qua một driver lỗi, ta có thể chèn một byte `\xC3` vào ngay phần đầu của `EtwTiLogReadWriteVm` và bypass ETW. Cách này phức tạp hơn nhiều so với cách đầu tiên do ta phải lấy base address của kernel (`NtQuerySystemInformation`) để tìm offset của `EtwTiLogReadWriteVm` trong `ntoskrnl.exe` và bắt đầu patch, chưa kể đến việc ta phải tìm một driver có lỗ hổng để có thể patch thành công.

   ```
   fffff804`0e45291c 4183f910        cmp     r9d,10h
   fffff804`0e452920 b800000c00      mov     eax,0C0000h
   fffff804`0e452925 41b800000300    mov     r8d,30000h
   ```

3. Patch member `LevelPlus1` của struct `_TlgProvider_t` thành `0` trong các tiến trình có sử dụng ETW. Struct này được sử dụng để khởi tạo ETW provider handle, ví dụ:

   ```c
   #include <TraceLoggingProvider.h>
   // Define a handle to a TraceLogging provider
   TRACELOGGING_DEFINE_PROVIDER(
       g_hMyComponentProvider,
       "SimpleTraceLoggingProvider",
       // {0205c616-cf97-5c11-9756-56a2cee02ca7}
       (0x0205c616,0xcf97,0x5c11,0x97,0x56,0x56,0xa2,0xce,0xe0,0x2c,0xa7));
   void main()
   {
       char sampleValue[] = "Sample value";
   
       // Register the provider
       TraceLoggingRegister(g_hMyComponentProvider);
   
       // Log an event
       TraceLoggingWrite(g_hMyComponentProvider, // handle to my provider
           "HelloWorldTestEvent",              // Event Name that should uniquely identify your event.
           TraceLoggingValue(sampleValue, "TestMessage")); // Field for your event in the form of (value, field name).
   
       // Stop TraceLogging and unregister the provider
       TraceLoggingUnregister(g_hMyComponentProvider);
   }
   ```

   Toàn bộ member của struct `_TlgProvider_t`:

   ```c
   struct _TlgProvider_t
   {
       UINT32 LevelPlus1;
       UINT16 const UNALIGNED* ProviderMetadataPtr; // Points to the RemainingSize member of provider metadata.
       ULONGLONG KeywordAny;
       ULONGLONG KeywordAll;
       REGHANDLE RegHandle;
       TLG_PENABLECALLBACK EnableCallback;
       PVOID CallbackContext;
   };
   ```

   Giờ ta hãy theo dõi bước khởi tạo ETW trong `combase.dll`:

   ```assembly
     cmp     _Tlgg_hCombaseTraceLoggingProviderProv.LevelPlus1, 5
     jbe     skip_logging
     push    useTimer                      ; keyword
     push    useTimer                      ; hProvider
     call    __TlgKeywordOn@12             ; _TlgKeywordOn(x,x,x)
     test    al, al
     jz      skip_logging
   ```

   Để ý nếu member `_Tlgg_hCombaseTraceLoggingProviderProv.LevelPlus1` nhỏ hơn hoặc bằng `5` thì tiến trình sẽ "bỏ qua" và không khởi tạo được ETW nữa. Một cách khác tương tự là ta sửa member `KeywordAny` hoặc `KeywordAll` thành `0` thì cũng sẽ đạt được kết quả tương tự do hàm `__TlgKeywordOn` kiểm tra các giá trị sau:

   ```c
   BOOLEAN _TlgKeywordOn(
       TraceLoggingHProvider _In_ hProvider,
       ULONGLONG keyword)
       TLG_NOEXCEPT
   {
       return keyword == 0 || (
           (keyword & hProvider->KeywordAny) &&
           (keyword & hProvider->KeywordAll) == hProvider->KeywordAll);
   }
   ```

4. Tạo một vùng nhớ cục bộ với quyền `RW-`, ghi shellcode hoặc map PE lên vùng nhớ này (PE buffer nên được mã hoá trước khi map), sau đó tiếp tục tạo một vùng nhớ với quyền `RW-` tương tự đến tiến trình cần inject (tạm gọi là `X`), release vùng nhớ cục bộ và cuối cùng là sửa quyền của vùng nhớ trên tiến trình `X` thành `RWX` và chạy shellcode. Mục đích của cách làm này là do **ETW chỉ log lại các vùng nhớ được tạo với quyền** `W` nên về mặt lý thuyết thì cách này có thể bypass một vài AV sử dụng ETW.

#### AMSI

##### Khái niệm

Antimalware Scan Interface hay AMSI thường được các dịch vụ AV sử dụng để phân tích các lệnh PowerShell. AMSI cho phép các AV bắt mọi câu lệnh không chỉ PowerShell mà có cả JScript, VBScript, VBA, lệnh .NET trong thời gian thực.

Bằng cách chèn `amsi.dll` vào tất cả các session/tiến trình PowerShell, PowerShell_ISE, các lệnh PS lúc này được truyền vào các hàm như `AmsiScanBuffer`, `AmsiScanString` và dữ liệu sẽ di chuyển qua lại giữa module phân tích của AV và session/tiến trình sử dụng PS đó thông qua RPC.

`amsi.dll` export và cho phép sử dụng các hàm sau:

- `AmsiInitialize`
- `AmsiOpenSession`
- `AmsiScanString`
- `AmsiScanBuffer`

AV sau khi nhận được buffer hoặc chuỗi chứa toàn bộ lệnh PS thì nó sẽ sử dụng cơ chế pattern scan như ở phần phân tích tĩnh đã giải thích. Windows Defender thường hay sử dụng cách này và hardcode rất nhiều chuỗi đối với các exploit phổ biến như bất kì chuỗi nào có chứa "Mimikatz", "Cobalt Strike" hoặc gọi các hàm theo một trình tự khả nghi như `Invoke-Command -> Invoke-WebRequest -> Invoke-Expression `.

##### Bypass AMSI

Malware có thể bypass AMSI bằng những phương pháp như:

- Sử dụng PowerShell 2 để thực thi mã độc do phiên bản này mặc dù đã lỗi thời và không có AMSI nhưng nó vẫn chưa bị xoá

- Có thể encode payload để bypass một số AV, tuy nhiên cách này có khả năng thành công rất thấp

- Hook `AmsiScanBuffer` bằng cách inject DLL vào tiến trình đang sử dụng PS, truyền tham số rỗng vào `AmsiScanBuffer` và thực thi mã độc tuỳ ý

- Chỉnh sửa trường `amsiContext` vì AMSI được khởi tạo từ `AmsiInitialize` và sau đó, hàm `AmsiOpenSession` sẽ kiểm tra xem nếu như 4 byte đầu tiên của `amsiContext` có bằng với `0x49534d41 ("AMSI")` hay không

  ```
  > u amsi!AmsiOpenSession
  amsi!AmsiOpenSession:
  ...
  	cmp dword ptr [rcx],  49534D41h		; "AMSI"
  	jne amsi!AmsiOpenSession+0x4b
  ...
  
  amsi!AmsiOpenSession+0x4b:
  	mov eax, 80070057h					; return 0x80070057
  	ret
  ...
  ```

  nên ta chỉ cần thay đổi 4 byte đầu này sao cho khác với "AMSI" thì AMSI sẽ không thể khởi tạo được. Cách này rất hiệu quả và khó bị phát hiện do attacker không cần phải inject bất kỳ đoạn code hay DLL nào. Tuy vậy, ta vẫn phải biết được offset của `amsiContext` bằng cách đọc giá trị mà chính `amsiContext` trỏ tới

- Đơn giản hơn thì ta có thể patch hai byte đầu tiên của `amsi!AmsiOpenSession` từ `test` thành `xor` để set cờ `ZF=1` và thực thi `je amsi!AmsiOpenSession+0x4b`:

  ```
  > u amsi!AmsiOpenSession
  amsi!AmsiOpenSession:
  	test rdx, rdx					; <----- xor rax, rax
  	je amsi!AmsiOpenSession+0x4b	; <----- ZF=0, execute
  	...
  	test rcx, rcx
  	je amsi!AmsiOpenSession+0x4b
  	...
  	cmp dword ptr [rcx],  49534D41h		; [rcx] đang trỏ đến amsiContext như ở bước trên đã giải thích
  	jne amsi!AmsiOpenSession+0x4b
  	...
  	cmp qword ptr [rcx+0x8], 0
  	je amsi!AmsiOpenSession+0x4b
  	...
  amsi!AmsiOpenSession+0x4b:				; ERROR -> EXIT
  	mov eax, 80070057h					; return 0x80070057
  	ret
  ```

  > Lý do tại sao lại phải đổi cả `test rdx, rdx` thành `xor rax, rax` là vì kích thước trong bộ nhớ của cả hai lệnh này là tương đương, `sizeof(0x4885d2) == sizeof(0x0431c0) == 3`.

### c. Cơ chế tự bảo vệ

Hầu hết AV hiện đại đều có cơ chế tự bảo vệ các mô-đun của nó không bị chỉnh sửa, can thiệp hoặc bị tắt đi bởi các phần mềm độc hại. Các tính năng thường thấy của cơ chế này bao gồm như:

- Các người dùng thông thường và thậm chí cả người dùng với quyền quản trị (administrator) cũng không thể tuỳ ý đóng các tiến trình đang chạy của AV bằng cách thông thường (end process của Task Manager, taskkill, ...)

- Bảo vệ tính toàn vẹn và ngăn chặn truy cập vào hệ thống file và khoá registry của AV

- Các dịch vụ (service) của AV thường đã được cấu hình DACL nên cả người dùng thông thường hay có quyền quản trị đều không thể truy vấn thông tin hay chỉnh sửa thông số của các dịch vụ này

- Các tiến trình và dịch vụ của một số AV sẽ nằm dưới quyền quản lý của một tài khoản đặc biệt mà ta không thể truy cập hoặc truy vấn thông tin.

  ![](https://raw.githubusercontent.com/Z3r0Un1x/reports/main/img-container/2022-05-26_14-58.png)

- Đa phần các AV sẽ có một mô-đun chạy kèm để quản lý và theo dõi liên tục các tiến trình thuộc AV đó, các mô-đun này thường sẽ giao tiếp với driver của AV ở tầng kernel và bảo vệ vùng nhớ của các mô-đun khác.P
- Cuối cùng là sử dụng cơ chế **P**rotected **P**rocess **L**ight (PPL) của Microsoft, cũng là cách phổ biến nhất.

#### Protected Process Light

##### Khái niệm

Kể từ Windows 8.1, một mô hình bảo vệ mới ở tầng kernel được thêm vào hệ điều hành và tên của mô hình này là Protected Process Light. Cách thức hoạt động của mô hình này là Windows sẽ xét tính toàn vẹn của một tiến trình và chỉ cho phép những tiến trình được tin tưởng này chạy dưới sự kiểm soát của PPL. Vậy khi được load trong PPL, các tiến trình này sẽ được Windows bảo vệ khỏi các kỹ thuật như code injection và các cách tấn công khác khi malware có quyền administrator. Việc này hoàn toàn khả thi do **chỉ có các tiến trình trong PPL mới có thể tương tác với nhau** mà các tiến trình nằm ngoài mô hình này không thể chỉnh sửa hay giả mạo được. Nhờ vào PPL, bản thân các AV không cần phải tốn tài nguyên cho các tiến trình tự bảo vệ khác.

Kể cả với quyền của `nt authority\system` và `SeDebugPrivilege`, ta cũng không thể tắt được các tiến trình thuộc PPL:

```
C:\WINDOWS\system32>whoami
nt authority\system

C:\WINDOWS\system32>whoami /priv | findstr "Debug"
SeDebugPrivilege Debug programs Enabled

C:\WINDOWS\system32>taskkill /f /im MsMpEng.exe
ERROR: The process "MsMpEng.exe" with PID 2236 could not be terminated.
Reason: Access is denied.
```

Tuy nhiên, Microsoft cũng rất rõ ràng và gắt gao trong việc cấp quyền để các chương trình được bảo vệ bằng mô hình PPL để tránh việc malware lợi dụng và thêm các tiến trình độc hại vào PPL. Để có thể chạy một tiến trình PPL, các nhà cung cấp dịch vụ AV phải trải qua một quá trình chọn lọc (vetting process) để chứng minh phần mềm của họ có thể tin tưởng được, tiếp đến AV phải cài thêm một driver đặc biệt gọi là ELAM (Early Lauch Anti-Malware) driver và có đầy đủ chữ kỹ điện tử (Code Signing) để Microsoft Authenticode xét duyệt. Sau toàn bộ các bước trên, AV có thể sử dụng ELAM driver được cấp để thêm các tiến trình của họ vào PPL.

##### Thay đổi token của tiến trình để vô hiệu PPL

Để có thể bypass được PPL, giả sử ta đã có quyền SYSTEM và giờ ta muốn tắt một tiến trình PPL của AV thì do mỗi tiến trình (kể cả PPL) đều được chia quyền và xác định bằng một dạng token (Token Security Descriptor) bao gồm các SID. Một chuỗi SID của một tiến trình sẽ đại diện cho quyền và sở hữu của tiến trình đó, ví dụ như một chuỗi SID của tiến trình thuộc Windows:

![](https://raw.githubusercontent.com/Z3r0Un1x/reports/main/img-container/2022-05-26_15-55.png)

Ta có thể thấy chuỗi SID của `wininit.exe` là `S-1-5-18`, tra trong bảng RID của MSDN

![](https://raw.githubusercontent.com/Z3r0Un1x/reports/main/img-container/2022-05-26_15-57.png)

ta thấy được `wininit.exe` có quyền SYSTEM, được quản lý bởi một tài khoản đặc biệt của hệ thống và đặc biệt, `wininit.exe` cũng là một PPL (`PsProtectedSignerWinTcb-Light`). Để có thể tắt được tiến trình này thì lúc trước ta chỉ cần thay đổi token của `wininit.exe` thành token của một tiến trình thông thường và `wininit.exe` sẽ mất đi sự bảo vệ từ PPL.

Windows đã có bản vá cho kiểu tấn công này bằng cách thêm một ACE cho SACL là "TrustLabel" cho các PPL. Windows sẽ tìm và lọc ra các tiến trình có TrustLabel ACE và chặn quyền TOKEN_WRITE đến các tiến trình này.

Ngoài ra, một số AV cũng sử dụng PPLGuard để thêm TrustLabel ACE vào các tiến trình của bản thân để cải thiện cơ chế tự bảo vệ.

##### Thay đổi giá trị trong struct EPROCESS để tắt PPL của tiến trình bất kỳ

Toàn bộ settings bảo vệ của PPL đều dựa trên một member `_PS_PROTECTION` thuộc struct với tên gọi là `EPROCESS` và Windows tới thời điểm của bài viết này vẫn chưa có bản vá nào cho lỗ hổng này.

![](D:/repos/reports/img-container/2022-06-29_10-04.png)

Bằng cách lợi dụng một driver có chữ ký hợp lệ, attacker hoàn toàn có thể thay đổi `Level` của struct này và vô hiệu hoá PPL của mọi tiến trình mà không bị PatchGuard phát hiện hay BSOD.

![](D:/repos/reports/img-container/2022-06-29_10-08.png)

#### Mini-filter driver

Không chỉ bảo vệ các tiến trình, AV cũng cần phải chú ý đến sự thay đổi trong hệ thống file và các khoá registry của bản thân để tránh các trường hợp malware có thể thay đổi tên, chỉnh sửa dữ liệu hay xoá những dữ liệu quan trọng. Bằng cách tạo và đăng ký một mini-filter driver, AV có thể bắt và chặn các yêu cầu truy cập đến các file và khoá registry đặc biệt như: Vị trí những đối tượng whitelist, flag bật tắt các tính năng bảo vệ, tên của các file mô-đun chính, tham số của service lưu trong registry hay AV settings nói chung.

Mini-filter driver sẽ đăng ký các routine như PreCreateFile, PreWriteFile, PreSetFileInformation (`IRP_MJ_CREATE`, `IRP_MJ_WRITE` và `IRP_MJ_SET_INFORMATION`) và trả về `STATUS_ACCESS_DENIED` mỗi khi các hàm CreateFile, WriteFile, SetFileInformation có chứa tham số đến các file hay khoá registry liên quan.

```c
...
// minifilter-precreatefile.c
FLT_PREOP_CALLBACK_STATUS PreCreateFileRoutine(PFLT_CALLBACK_DATA Data, PCFLT_RELATED_OBJECTS,
	PVOID*)
{
	if (Data->Iopb->Parameters.Create.Options & FILE_DELETE_ON_CLOSE)
	{
		FileNameInfo FnIObject(Data);
		if(nullptr != FnIObject.get())
		{
			if(wcsstr(FnIObject.get()->Buffer, TEXT("ProtectedFolder")))
			{
				Data->IoStatus.Status = STATUS_ACCESS_DENIED;
				return FLT_PREOP_COMPLETE;
			}
		}
	}
	return FLT_PREOP_SUCCESS_NO_CALLBACK;
}
```

Ngoài ra, đối với các khoá registry, AV sẽ sử dụng security descriptor để cài đặt các ACE lên các khoá này (Windows Defender) và ngăn không để người dùng hay mã độc có thể tuỳ ý chỉnh sửa giá trị. Bằng cách tạo một "tài khoản ma" (không thể truy cập) trên Windows với một RID riêng biệt và sử dụng tài khoản này để chứa DACL, từ đó quản lý registry và thậm chí hệ thống file.

![](https://raw.githubusercontent.com/Z3r0Un1x/reports/main/img-container/2022-06-27_10-50.png)

Tuy nhiên cách này vẫn có thể dễ dàng bị bypass khi mã độc có quyền cao hơn Administrator (`NT AUTHORITY\SYSTEM` hoặc `BUILTIN\Administrators`) nên việc bảo vệ khoá vẫn phụ thuộc vào Mini-filter là chính.

![](https://raw.githubusercontent.com/Z3r0Un1x/reports/main/img-container/2022-06-27_11-04.png)

## III. Cách AV cách ly malware

Sau khi đã nhận diện được malware, các AV thường cho chúng ta các lựa chọn như: Xoá, Cách ly, Bỏ qua, ... một số AV mới còn có công nghệ khử mã độc nâng cao nhằm xoá đi chỉ phần đoạn mã gây hại và để lại chương trình sạch cho người dùng, thường là các file phim ảnh, crack game hoặc các phần mềm lậu khác. Ở phần này ta sẽ nói về việc AV cách ly malware như thế nào.

Việc AV cho phép ta cách ly những file được xem là malware là để phòng trường hợp nhầm lẫn (false positive) và người dùng có thể chọn phục hồi lại file bị cách ly đó hay không. Khi cách ly, phần mềm AV phải chắc chắn rằng người dùng không vô tình bấm lại và thực thi file mã độc đó nên thường chúng sẽ có một cơ chế mã hoá file hẳn hoi chứ không chỉ đơn giản là đổi phần mở rộng.

EICAR test file trước và sau khi được cách ly:

![](https://raw.githubusercontent.com/Z3r0Un1x/reports/main/img-container/2022-05-26_16-30.png)

![](https://raw.githubusercontent.com/Z3r0Un1x/reports/main/img-container/2022-05-26_16-30_1.png)

Thay đổi tên và biến đổi lại một chút:

![](https://raw.githubusercontent.com/Z3r0Un1x/reports/main/img-container/2022-05-26_16-35.png)

Ta thấy được tên file được đổi thành một dạng hash SHA1 và cả 2 file cách ly đều có phần mở đầu tương tự nhau (`0B AD 00 98 91 FD DE`), phần này có thể xem như signature của file cách ly. Để có thể khôi phục lại những file này, Windows Defender sẽ có một cơ chế decrypt riêng, đối với những loại AV khác như Kaspersky, Sophos, Malwarebytes thì các thuật toán cơ bản như XOR, RC4, ... cũng được sử dụng để mã hoá file cách ly.

## IV. Một số thông tin đáng chú ý khác

Một số tính năng đặc biệt khác của AV hiện nay bao gồm:

- Tích hợp hệ thống plugin/addon
- Tường lửa và khả năng phân tích, chặn gói tin
- Các service/daemon để quản lý hoạt động và đóng vai trò như một trình giao tiếp giữa giao diện người dùng và hệ thống xử lý lõi của AV

### a. Hệ thống plugin

Plugin hay addon là một phần nhỏ trong hệ thống quản lý và nhận diện của AV. Những plugin này được sử dụng để mở rộng thêm một số các tính năng như giải nén file (ZIP, RAR, 7z, ...), hỗ trợ unpack (UPX, VMProtect, ...), công cụ giả lập Intel x86, sandbox hay plugin đọc các file với định dạng đặc biệt như PDF, DOCX, XLSX. 

Những plugin/addon này được load trong lúc AV thực thi các tính năng liên quan bằng một cơ chế thủ công riêng biệt (mỗi AV khác nhau có cách load plugin khác nhau), và cách phổ biến nhất chính là tạo một vùng nhớ với quyền RWX trên heap, giải mã và giải nén các plugin này lên vùng nhớ vừa tạo, chỉnh sửa lại quyền của vùng nhớ thành R-X, và cuối cùng là thêm vùng nhớ chứa plugin vào danh sách thực thi. Cách này còn được biết đến là dynamic loading.

Một số dịch vụ AV có cách load plugin khác như ghép các plugin thành một file DLL (container) hoặc chia nhỏ theo từng tính năng, các DLL này sẽ được mã hoá theo một cơ chế nào đó. Ví dụ như Avira AV thường hay mã hoá toàn bộ chuỗi có trong DLL plugin và chỉ giải mã chúng khi cần thiết bằng một thuật toán XOR đơn giản với key nằm hẳn trong file DLL plugin. Hay đối với Kaspersky thì các plugin được lưu dưới dạng COFF (được mã hoá bằng thuật toán XOR-ADD và nén lại), sau đó Kaspersky sẽ dùng linker riêng của nó (các routine trong `AvpBase.dll`) để link các file COFF này lại với nhau và sử dụng.

Với cách dynamic loading, việc dịch ngược các plugin này trở nên khó hơn rất nhiều do ASLR sẽ thay đổi địa chỉ vùng nhớ lưu plugin mỗi lần AV được khởi chạy nên mọi breakpoint, tên hàm sẽ bị mất và trỏ đến một địa chỉ không hợp lệ trong bộ nhớ. Một số cách để cải thiện điểm trên đó là tắt ASLR, tuy nhiên một số AV (Sophos - `BOPS.dll`) lại có cơ chế tự điều chỉnh ASLR cho bộ nhớ của nó (và các tiến trình khác) mà không cần đến ASLR của hệ điều hành.

### b. Tường lửa

Do số lượng tăng lên đáng kể của các loại mã độc có tính lây lan trong không gian mạng, các dịch vụ AV cũng đã có biện pháp đối phó bằng cách đăng ký các mini-filter driver để hỗ trợ Windows Firewall mặc định hoặc thậm chí thay thế hoàn toàn tường lửa của Microsoft (Kaspersky Internet Security, Avast, ...).

Các tường lửa này có cơ chế hoạt động tương đồng với Windows Firewall, điểm khác biệt lớn nhất có lẽ là rule-set database (cơ sở các quy tắc) chặn và cơ chế phân tích gói tin chuyên sâu (in-depth packet analysis). Windows Firewall không thể nhận diện được các gói tin đã bị mã hoá hoặc một số mã độc có thể sử dụng những protocol hoàn toàn mới (custom) nên AV sẽ đăng ký một driver mạng sử dụng WFP (Windows Filtering Platform) hoặc tương tác trực tiếp với BFE (Base Filtering Engine) để phân tích từng gói tin một. Một số AV sử dụng điện toán đám mây (Sophos Hitman.Alert) sẽ sử dụng thêm Private Cloud-based Firewall và hoạt động theo cơ chế SaaS giúp nhận diện và xử lý gói tin triệt để hơn.

### c. Cách thức tương tác giữa AV core và các mô-đun

Một số AV có các trình quản lý trên giao diện cửa sổ dòng lệnh (CLI/console) để hỗ trợ GUI như Avast, Comodo, ...

Các file CLI này sẽ giao tiếp với AV core thông qua mô hình client-server:

- Một file thực thi sẽ chạy dưới dạng service và bắt các yêu cầu quét, phân tích, cách ly, lưu trữ từ công cụ CLI
- Công cụ CLI sẽ có đầy đủ tính năng của phiên bản GUI và sẽ gửi các yêu cầu liên quan đến server sau đó đợi thông báo trả về từ server

Đa phần giao thức giao tiếp của mô hình này thường là truy vấn plain-text, socket, HTTP, hoặc thông qua pipe (pipe server và pipe client). Những dữ liệu truyền tải trong mô hình trên thường không được mã hoá nên việc fuzzing các lỗi hoặc lỗ hổng có trong AV rất dễ được phát hiện ở tính năng này.

## Tài liệu tham khảo

1. https://redplait.blogspot.com/2020/07/tlgprovidert.html
2. https://attack.mitre.org/techniques/T1055/004/
3. https://docs.microsoft.com/en-us/windows/win32/etw/event-tracing-portal
4. https://blog.redbluepurple.io/windows-security-research/kernel-tracing-injection-detection
5. https://www.ired.team/offensive-security/code-injection-process-injection/apc-queue-code-injection
6. https://papers.vx-underground.org/papers/Malware%20Defense/AV%20Tech/Minifilters%20for%20detection%20of%20Malware.pdf
7. https://rce4fun.blogspot.com/2019/03/examining-user-mode-apc-injection.html
8. https://0x00sec.org/t/kernel-mode-rootkits-file-deletion-protection/7616

